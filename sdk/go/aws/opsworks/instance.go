// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package opsworks

import (
	"context"
	"reflect"
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides an OpsWorks instance resource.
// 
// ## Block devices
// 
// Each of the `*_block_device` attributes controls a portion of the AWS
// Instance's "Block Device Mapping". It's a good idea to familiarize yourself with [AWS's Block Device
// Mapping docs](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html)
// to understand the implications of using these attributes.
// 
// The `rootBlockDevice` mapping supports the following:
// 
// * `volumeType` - (Optional) The type of volume. Can be `"standard"`, `"gp2"`,
//   or `"io1"`. (Default: `"standard"`).
// * `volumeSize` - (Optional) The size of the volume in gigabytes.
// * `iops` - (Optional) The amount of provisioned
//   [IOPS](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
//   This must be set with a `volumeType` of `"io1"`.
// * `deleteOnTermination` - (Optional) Whether the volume should be destroyed
//   on instance termination (Default: `true`).
// 
// Modifying any of the `rootBlockDevice` settings requires resource
// replacement.
// 
// Each `ebsBlockDevice` supports the following:
// 
// * `deviceName` - The name of the device to mount.
// * `snapshotId` - (Optional) The Snapshot ID to mount.
// * `volumeType` - (Optional) The type of volume. Can be `"standard"`, `"gp2"`,
//   or `"io1"`. (Default: `"standard"`).
// * `volumeSize` - (Optional) The size of the volume in gigabytes.
// * `iops` - (Optional) The amount of provisioned
//   [IOPS](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html).
//   This must be set with a `volumeType` of `"io1"`.
// * `deleteOnTermination` - (Optional) Whether the volume should be destroyed
//   on instance termination (Default: `true`).
// 
// Modifying any `ebsBlockDevice` currently requires resource replacement.
// 
// Each `ephemeralBlockDevice` supports the following:
// 
// * `deviceName` - The name of the block device to mount on the instance.
// * `virtualName` - The [Instance Store Device
//   Name](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
//   (e.g. `"ephemeral0"`)
// 
// Each AWS Instance type has a different set of Instance Store block devices
// available for attachment. AWS [publishes a
// list](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#StorageOnInstanceTypes)
// of which ephemeral devices are available on each type. The devices are always
// identified by the `virtualName` in the format `"ephemeral{0..N}"`.
// 
// > **NOTE:** Currently, changes to `*_block_device` configuration of _existing_
// resources cannot be automatically detected by this provider. After making updates
// to block device configuration, resource recreation can be manually triggered by
// using the [`taint` command](https://www.terraform.io/docs/commands/taint.html).
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/opsworks_instance.html.markdown.
type Instance struct {
	pulumi.CustomResourceState

	// The AWS OpsWorks agent to install.  Defaults to `"INHERIT"`.
	AgentVersion pulumi.StringOutput `pulumi:"agentVersion"`

	// The AMI to use for the instance.  If an AMI is specified, `os` must be `"Custom"`.
	AmiId pulumi.StringOutput `pulumi:"amiId"`

	// Machine architecture for created instances.  Can be either `"x8664"` (the default) or `"i386"`
	Architecture pulumi.StringOutput `pulumi:"architecture"`

	// Creates load-based or time-based instances.  If set, can be either: `"load"` or `"timer"`.
	AutoScalingType pulumi.StringOutput `pulumi:"autoScalingType"`

	// Name of the availability zone where instances will be created
	// by default.
	AvailabilityZone pulumi.StringOutput `pulumi:"availabilityZone"`

	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`

	DeleteEbs pulumi.BoolOutput `pulumi:"deleteEbs"`

	DeleteEip pulumi.BoolOutput `pulumi:"deleteEip"`

	// Additional EBS block devices to attach to the
	// instance.  See Block Devices below for details.
	EbsBlockDevices InstanceEbsBlockDevicesArrayOutput `pulumi:"ebsBlockDevices"`

	// If true, the launched EC2 instance will be EBS-optimized.
	EbsOptimized pulumi.BoolOutput `pulumi:"ebsOptimized"`

	// EC2 instance ID
	Ec2InstanceId pulumi.StringOutput `pulumi:"ec2InstanceId"`

	EcsClusterArn pulumi.StringOutput `pulumi:"ecsClusterArn"`

	ElasticIp pulumi.StringOutput `pulumi:"elasticIp"`

	// Customize Ephemeral (also known as
	// "Instance Store") volumes on the instance. See Block Devices below for details.
	EphemeralBlockDevices InstanceEphemeralBlockDevicesArrayOutput `pulumi:"ephemeralBlockDevices"`

	// The instance's host name.
	Hostname pulumi.StringOutput `pulumi:"hostname"`

	InfrastructureClass pulumi.StringOutput `pulumi:"infrastructureClass"`

	// Controls where to install OS and package updates when the instance boots.  Defaults to `true`.
	InstallUpdatesOnBoot pulumi.BoolOutput `pulumi:"installUpdatesOnBoot"`

	InstanceProfileArn pulumi.StringOutput `pulumi:"instanceProfileArn"`

	// The type of instance to start
	InstanceType pulumi.StringOutput `pulumi:"instanceType"`

	LastServiceErrorId pulumi.StringOutput `pulumi:"lastServiceErrorId"`

	// The ids of the layers the instance will belong to.
	LayerIds pulumi.StringArrayOutput `pulumi:"layerIds"`

	// Name of operating system that will be installed.
	Os pulumi.StringOutput `pulumi:"os"`

	Platform pulumi.StringOutput `pulumi:"platform"`

	// The private DNS name assigned to the instance. Can only be
	// used inside the Amazon EC2, and only available if you've enabled DNS hostnames
	// for your VPC
	PrivateDns pulumi.StringOutput `pulumi:"privateDns"`

	// The private IP address assigned to the instance
	PrivateIp pulumi.StringOutput `pulumi:"privateIp"`

	// The public DNS name assigned to the instance. For EC2-VPC, this
	// is only available if you've enabled DNS hostnames for your VPC
	PublicDns pulumi.StringOutput `pulumi:"publicDns"`

	// The public IP address assigned to the instance, if applicable.
	PublicIp pulumi.StringOutput `pulumi:"publicIp"`

	RegisteredBy pulumi.StringOutput `pulumi:"registeredBy"`

	ReportedAgentVersion pulumi.StringOutput `pulumi:"reportedAgentVersion"`

	ReportedOsFamily pulumi.StringOutput `pulumi:"reportedOsFamily"`

	ReportedOsName pulumi.StringOutput `pulumi:"reportedOsName"`

	ReportedOsVersion pulumi.StringOutput `pulumi:"reportedOsVersion"`

	// Customize details about the root block
	// device of the instance. See Block Devices below for details.
	RootBlockDevices InstanceRootBlockDevicesArrayOutput `pulumi:"rootBlockDevices"`

	// Name of the type of root device instances will have by default.  Can be either `"ebs"` or `"instance-store"`
	RootDeviceType pulumi.StringOutput `pulumi:"rootDeviceType"`

	RootDeviceVolumeId pulumi.StringOutput `pulumi:"rootDeviceVolumeId"`

	// The associated security groups.
	SecurityGroupIds pulumi.StringArrayOutput `pulumi:"securityGroupIds"`

	SshHostDsaKeyFingerprint pulumi.StringOutput `pulumi:"sshHostDsaKeyFingerprint"`

	SshHostRsaKeyFingerprint pulumi.StringOutput `pulumi:"sshHostRsaKeyFingerprint"`

	// Name of the SSH keypair that instances will have by default.
	SshKeyName pulumi.StringOutput `pulumi:"sshKeyName"`

	// The id of the stack the instance will belong to.
	StackId pulumi.StringOutput `pulumi:"stackId"`

	// The desired state of the instance.  Can be either `"running"` or `"stopped"`.
	State pulumi.StringOutput `pulumi:"state"`

	Status pulumi.StringOutput `pulumi:"status"`

	// Subnet ID to attach to
	SubnetId pulumi.StringOutput `pulumi:"subnetId"`

	// Instance tenancy to use. Can be one of `"default"`, `"dedicated"` or `"host"`
	Tenancy pulumi.StringOutput `pulumi:"tenancy"`

	// Keyword to choose what virtualization mode created instances
	// will use. Can be either `"paravirtual"` or `"hvm"`.
	VirtualizationType pulumi.StringOutput `pulumi:"virtualizationType"`
}

// NewInstance registers a new resource with the given unique name, arguments, and options.
func NewInstance(ctx *pulumi.Context,
	name string, args *InstanceArgs, opts ...pulumi.ResourceOption) (*Instance, error) {
	if args == nil || args.LayerIds == nil {
		return nil, errors.New("missing required argument 'LayerIds'")
	}
	if args == nil || args.StackId == nil {
		return nil, errors.New("missing required argument 'StackId'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.AgentVersion; i != nil { inputs["agentVersion"] = i.ToStringOutput() }
		if i := args.AmiId; i != nil { inputs["amiId"] = i.ToStringOutput() }
		if i := args.Architecture; i != nil { inputs["architecture"] = i.ToStringOutput() }
		if i := args.AutoScalingType; i != nil { inputs["autoScalingType"] = i.ToStringOutput() }
		if i := args.AvailabilityZone; i != nil { inputs["availabilityZone"] = i.ToStringOutput() }
		if i := args.CreatedAt; i != nil { inputs["createdAt"] = i.ToStringOutput() }
		if i := args.DeleteEbs; i != nil { inputs["deleteEbs"] = i.ToBoolOutput() }
		if i := args.DeleteEip; i != nil { inputs["deleteEip"] = i.ToBoolOutput() }
		if i := args.EbsBlockDevices; i != nil { inputs["ebsBlockDevices"] = i.ToInstanceEbsBlockDevicesArrayOutput() }
		if i := args.EbsOptimized; i != nil { inputs["ebsOptimized"] = i.ToBoolOutput() }
		if i := args.EcsClusterArn; i != nil { inputs["ecsClusterArn"] = i.ToStringOutput() }
		if i := args.ElasticIp; i != nil { inputs["elasticIp"] = i.ToStringOutput() }
		if i := args.EphemeralBlockDevices; i != nil { inputs["ephemeralBlockDevices"] = i.ToInstanceEphemeralBlockDevicesArrayOutput() }
		if i := args.Hostname; i != nil { inputs["hostname"] = i.ToStringOutput() }
		if i := args.InfrastructureClass; i != nil { inputs["infrastructureClass"] = i.ToStringOutput() }
		if i := args.InstallUpdatesOnBoot; i != nil { inputs["installUpdatesOnBoot"] = i.ToBoolOutput() }
		if i := args.InstanceProfileArn; i != nil { inputs["instanceProfileArn"] = i.ToStringOutput() }
		if i := args.InstanceType; i != nil { inputs["instanceType"] = i.ToStringOutput() }
		if i := args.LastServiceErrorId; i != nil { inputs["lastServiceErrorId"] = i.ToStringOutput() }
		if i := args.LayerIds; i != nil { inputs["layerIds"] = i.ToStringArrayOutput() }
		if i := args.Os; i != nil { inputs["os"] = i.ToStringOutput() }
		if i := args.Platform; i != nil { inputs["platform"] = i.ToStringOutput() }
		if i := args.PrivateDns; i != nil { inputs["privateDns"] = i.ToStringOutput() }
		if i := args.PrivateIp; i != nil { inputs["privateIp"] = i.ToStringOutput() }
		if i := args.PublicDns; i != nil { inputs["publicDns"] = i.ToStringOutput() }
		if i := args.PublicIp; i != nil { inputs["publicIp"] = i.ToStringOutput() }
		if i := args.RegisteredBy; i != nil { inputs["registeredBy"] = i.ToStringOutput() }
		if i := args.ReportedAgentVersion; i != nil { inputs["reportedAgentVersion"] = i.ToStringOutput() }
		if i := args.ReportedOsFamily; i != nil { inputs["reportedOsFamily"] = i.ToStringOutput() }
		if i := args.ReportedOsName; i != nil { inputs["reportedOsName"] = i.ToStringOutput() }
		if i := args.ReportedOsVersion; i != nil { inputs["reportedOsVersion"] = i.ToStringOutput() }
		if i := args.RootBlockDevices; i != nil { inputs["rootBlockDevices"] = i.ToInstanceRootBlockDevicesArrayOutput() }
		if i := args.RootDeviceType; i != nil { inputs["rootDeviceType"] = i.ToStringOutput() }
		if i := args.RootDeviceVolumeId; i != nil { inputs["rootDeviceVolumeId"] = i.ToStringOutput() }
		if i := args.SecurityGroupIds; i != nil { inputs["securityGroupIds"] = i.ToStringArrayOutput() }
		if i := args.SshHostDsaKeyFingerprint; i != nil { inputs["sshHostDsaKeyFingerprint"] = i.ToStringOutput() }
		if i := args.SshHostRsaKeyFingerprint; i != nil { inputs["sshHostRsaKeyFingerprint"] = i.ToStringOutput() }
		if i := args.SshKeyName; i != nil { inputs["sshKeyName"] = i.ToStringOutput() }
		if i := args.StackId; i != nil { inputs["stackId"] = i.ToStringOutput() }
		if i := args.State; i != nil { inputs["state"] = i.ToStringOutput() }
		if i := args.Status; i != nil { inputs["status"] = i.ToStringOutput() }
		if i := args.SubnetId; i != nil { inputs["subnetId"] = i.ToStringOutput() }
		if i := args.Tenancy; i != nil { inputs["tenancy"] = i.ToStringOutput() }
		if i := args.VirtualizationType; i != nil { inputs["virtualizationType"] = i.ToStringOutput() }
	}
	var resource Instance
	err := ctx.RegisterResource("aws:opsworks/instance:Instance", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstance gets an existing Instance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceState, opts ...pulumi.ResourceOption) (*Instance, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.AgentVersion; i != nil { inputs["agentVersion"] = i.ToStringOutput() }
		if i := state.AmiId; i != nil { inputs["amiId"] = i.ToStringOutput() }
		if i := state.Architecture; i != nil { inputs["architecture"] = i.ToStringOutput() }
		if i := state.AutoScalingType; i != nil { inputs["autoScalingType"] = i.ToStringOutput() }
		if i := state.AvailabilityZone; i != nil { inputs["availabilityZone"] = i.ToStringOutput() }
		if i := state.CreatedAt; i != nil { inputs["createdAt"] = i.ToStringOutput() }
		if i := state.DeleteEbs; i != nil { inputs["deleteEbs"] = i.ToBoolOutput() }
		if i := state.DeleteEip; i != nil { inputs["deleteEip"] = i.ToBoolOutput() }
		if i := state.EbsBlockDevices; i != nil { inputs["ebsBlockDevices"] = i.ToInstanceEbsBlockDevicesArrayOutput() }
		if i := state.EbsOptimized; i != nil { inputs["ebsOptimized"] = i.ToBoolOutput() }
		if i := state.Ec2InstanceId; i != nil { inputs["ec2InstanceId"] = i.ToStringOutput() }
		if i := state.EcsClusterArn; i != nil { inputs["ecsClusterArn"] = i.ToStringOutput() }
		if i := state.ElasticIp; i != nil { inputs["elasticIp"] = i.ToStringOutput() }
		if i := state.EphemeralBlockDevices; i != nil { inputs["ephemeralBlockDevices"] = i.ToInstanceEphemeralBlockDevicesArrayOutput() }
		if i := state.Hostname; i != nil { inputs["hostname"] = i.ToStringOutput() }
		if i := state.InfrastructureClass; i != nil { inputs["infrastructureClass"] = i.ToStringOutput() }
		if i := state.InstallUpdatesOnBoot; i != nil { inputs["installUpdatesOnBoot"] = i.ToBoolOutput() }
		if i := state.InstanceProfileArn; i != nil { inputs["instanceProfileArn"] = i.ToStringOutput() }
		if i := state.InstanceType; i != nil { inputs["instanceType"] = i.ToStringOutput() }
		if i := state.LastServiceErrorId; i != nil { inputs["lastServiceErrorId"] = i.ToStringOutput() }
		if i := state.LayerIds; i != nil { inputs["layerIds"] = i.ToStringArrayOutput() }
		if i := state.Os; i != nil { inputs["os"] = i.ToStringOutput() }
		if i := state.Platform; i != nil { inputs["platform"] = i.ToStringOutput() }
		if i := state.PrivateDns; i != nil { inputs["privateDns"] = i.ToStringOutput() }
		if i := state.PrivateIp; i != nil { inputs["privateIp"] = i.ToStringOutput() }
		if i := state.PublicDns; i != nil { inputs["publicDns"] = i.ToStringOutput() }
		if i := state.PublicIp; i != nil { inputs["publicIp"] = i.ToStringOutput() }
		if i := state.RegisteredBy; i != nil { inputs["registeredBy"] = i.ToStringOutput() }
		if i := state.ReportedAgentVersion; i != nil { inputs["reportedAgentVersion"] = i.ToStringOutput() }
		if i := state.ReportedOsFamily; i != nil { inputs["reportedOsFamily"] = i.ToStringOutput() }
		if i := state.ReportedOsName; i != nil { inputs["reportedOsName"] = i.ToStringOutput() }
		if i := state.ReportedOsVersion; i != nil { inputs["reportedOsVersion"] = i.ToStringOutput() }
		if i := state.RootBlockDevices; i != nil { inputs["rootBlockDevices"] = i.ToInstanceRootBlockDevicesArrayOutput() }
		if i := state.RootDeviceType; i != nil { inputs["rootDeviceType"] = i.ToStringOutput() }
		if i := state.RootDeviceVolumeId; i != nil { inputs["rootDeviceVolumeId"] = i.ToStringOutput() }
		if i := state.SecurityGroupIds; i != nil { inputs["securityGroupIds"] = i.ToStringArrayOutput() }
		if i := state.SshHostDsaKeyFingerprint; i != nil { inputs["sshHostDsaKeyFingerprint"] = i.ToStringOutput() }
		if i := state.SshHostRsaKeyFingerprint; i != nil { inputs["sshHostRsaKeyFingerprint"] = i.ToStringOutput() }
		if i := state.SshKeyName; i != nil { inputs["sshKeyName"] = i.ToStringOutput() }
		if i := state.StackId; i != nil { inputs["stackId"] = i.ToStringOutput() }
		if i := state.State; i != nil { inputs["state"] = i.ToStringOutput() }
		if i := state.Status; i != nil { inputs["status"] = i.ToStringOutput() }
		if i := state.SubnetId; i != nil { inputs["subnetId"] = i.ToStringOutput() }
		if i := state.Tenancy; i != nil { inputs["tenancy"] = i.ToStringOutput() }
		if i := state.VirtualizationType; i != nil { inputs["virtualizationType"] = i.ToStringOutput() }
	}
	var resource Instance
	err := ctx.ReadResource("aws:opsworks/instance:Instance", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Instance resources.
type InstanceState struct {
	// The AWS OpsWorks agent to install.  Defaults to `"INHERIT"`.
	AgentVersion pulumi.StringInput `pulumi:"agentVersion"`
	// The AMI to use for the instance.  If an AMI is specified, `os` must be `"Custom"`.
	AmiId pulumi.StringInput `pulumi:"amiId"`
	// Machine architecture for created instances.  Can be either `"x8664"` (the default) or `"i386"`
	Architecture pulumi.StringInput `pulumi:"architecture"`
	// Creates load-based or time-based instances.  If set, can be either: `"load"` or `"timer"`.
	AutoScalingType pulumi.StringInput `pulumi:"autoScalingType"`
	// Name of the availability zone where instances will be created
	// by default.
	AvailabilityZone pulumi.StringInput `pulumi:"availabilityZone"`
	CreatedAt pulumi.StringInput `pulumi:"createdAt"`
	DeleteEbs pulumi.BoolInput `pulumi:"deleteEbs"`
	DeleteEip pulumi.BoolInput `pulumi:"deleteEip"`
	// Additional EBS block devices to attach to the
	// instance.  See Block Devices below for details.
	EbsBlockDevices InstanceEbsBlockDevicesArrayInput `pulumi:"ebsBlockDevices"`
	// If true, the launched EC2 instance will be EBS-optimized.
	EbsOptimized pulumi.BoolInput `pulumi:"ebsOptimized"`
	// EC2 instance ID
	Ec2InstanceId pulumi.StringInput `pulumi:"ec2InstanceId"`
	EcsClusterArn pulumi.StringInput `pulumi:"ecsClusterArn"`
	ElasticIp pulumi.StringInput `pulumi:"elasticIp"`
	// Customize Ephemeral (also known as
	// "Instance Store") volumes on the instance. See Block Devices below for details.
	EphemeralBlockDevices InstanceEphemeralBlockDevicesArrayInput `pulumi:"ephemeralBlockDevices"`
	// The instance's host name.
	Hostname pulumi.StringInput `pulumi:"hostname"`
	InfrastructureClass pulumi.StringInput `pulumi:"infrastructureClass"`
	// Controls where to install OS and package updates when the instance boots.  Defaults to `true`.
	InstallUpdatesOnBoot pulumi.BoolInput `pulumi:"installUpdatesOnBoot"`
	InstanceProfileArn pulumi.StringInput `pulumi:"instanceProfileArn"`
	// The type of instance to start
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	LastServiceErrorId pulumi.StringInput `pulumi:"lastServiceErrorId"`
	// The ids of the layers the instance will belong to.
	LayerIds pulumi.StringArrayInput `pulumi:"layerIds"`
	// Name of operating system that will be installed.
	Os pulumi.StringInput `pulumi:"os"`
	Platform pulumi.StringInput `pulumi:"platform"`
	// The private DNS name assigned to the instance. Can only be
	// used inside the Amazon EC2, and only available if you've enabled DNS hostnames
	// for your VPC
	PrivateDns pulumi.StringInput `pulumi:"privateDns"`
	// The private IP address assigned to the instance
	PrivateIp pulumi.StringInput `pulumi:"privateIp"`
	// The public DNS name assigned to the instance. For EC2-VPC, this
	// is only available if you've enabled DNS hostnames for your VPC
	PublicDns pulumi.StringInput `pulumi:"publicDns"`
	// The public IP address assigned to the instance, if applicable.
	PublicIp pulumi.StringInput `pulumi:"publicIp"`
	RegisteredBy pulumi.StringInput `pulumi:"registeredBy"`
	ReportedAgentVersion pulumi.StringInput `pulumi:"reportedAgentVersion"`
	ReportedOsFamily pulumi.StringInput `pulumi:"reportedOsFamily"`
	ReportedOsName pulumi.StringInput `pulumi:"reportedOsName"`
	ReportedOsVersion pulumi.StringInput `pulumi:"reportedOsVersion"`
	// Customize details about the root block
	// device of the instance. See Block Devices below for details.
	RootBlockDevices InstanceRootBlockDevicesArrayInput `pulumi:"rootBlockDevices"`
	// Name of the type of root device instances will have by default.  Can be either `"ebs"` or `"instance-store"`
	RootDeviceType pulumi.StringInput `pulumi:"rootDeviceType"`
	RootDeviceVolumeId pulumi.StringInput `pulumi:"rootDeviceVolumeId"`
	// The associated security groups.
	SecurityGroupIds pulumi.StringArrayInput `pulumi:"securityGroupIds"`
	SshHostDsaKeyFingerprint pulumi.StringInput `pulumi:"sshHostDsaKeyFingerprint"`
	SshHostRsaKeyFingerprint pulumi.StringInput `pulumi:"sshHostRsaKeyFingerprint"`
	// Name of the SSH keypair that instances will have by default.
	SshKeyName pulumi.StringInput `pulumi:"sshKeyName"`
	// The id of the stack the instance will belong to.
	StackId pulumi.StringInput `pulumi:"stackId"`
	// The desired state of the instance.  Can be either `"running"` or `"stopped"`.
	State pulumi.StringInput `pulumi:"state"`
	Status pulumi.StringInput `pulumi:"status"`
	// Subnet ID to attach to
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
	// Instance tenancy to use. Can be one of `"default"`, `"dedicated"` or `"host"`
	Tenancy pulumi.StringInput `pulumi:"tenancy"`
	// Keyword to choose what virtualization mode created instances
	// will use. Can be either `"paravirtual"` or `"hvm"`.
	VirtualizationType pulumi.StringInput `pulumi:"virtualizationType"`
}

// The set of arguments for constructing a Instance resource.
type InstanceArgs struct {
	// The AWS OpsWorks agent to install.  Defaults to `"INHERIT"`.
	AgentVersion pulumi.StringInput `pulumi:"agentVersion"`
	// The AMI to use for the instance.  If an AMI is specified, `os` must be `"Custom"`.
	AmiId pulumi.StringInput `pulumi:"amiId"`
	// Machine architecture for created instances.  Can be either `"x8664"` (the default) or `"i386"`
	Architecture pulumi.StringInput `pulumi:"architecture"`
	// Creates load-based or time-based instances.  If set, can be either: `"load"` or `"timer"`.
	AutoScalingType pulumi.StringInput `pulumi:"autoScalingType"`
	// Name of the availability zone where instances will be created
	// by default.
	AvailabilityZone pulumi.StringInput `pulumi:"availabilityZone"`
	CreatedAt pulumi.StringInput `pulumi:"createdAt"`
	DeleteEbs pulumi.BoolInput `pulumi:"deleteEbs"`
	DeleteEip pulumi.BoolInput `pulumi:"deleteEip"`
	// Additional EBS block devices to attach to the
	// instance.  See Block Devices below for details.
	EbsBlockDevices InstanceEbsBlockDevicesArrayInput `pulumi:"ebsBlockDevices"`
	// If true, the launched EC2 instance will be EBS-optimized.
	EbsOptimized pulumi.BoolInput `pulumi:"ebsOptimized"`
	EcsClusterArn pulumi.StringInput `pulumi:"ecsClusterArn"`
	ElasticIp pulumi.StringInput `pulumi:"elasticIp"`
	// Customize Ephemeral (also known as
	// "Instance Store") volumes on the instance. See Block Devices below for details.
	EphemeralBlockDevices InstanceEphemeralBlockDevicesArrayInput `pulumi:"ephemeralBlockDevices"`
	// The instance's host name.
	Hostname pulumi.StringInput `pulumi:"hostname"`
	InfrastructureClass pulumi.StringInput `pulumi:"infrastructureClass"`
	// Controls where to install OS and package updates when the instance boots.  Defaults to `true`.
	InstallUpdatesOnBoot pulumi.BoolInput `pulumi:"installUpdatesOnBoot"`
	InstanceProfileArn pulumi.StringInput `pulumi:"instanceProfileArn"`
	// The type of instance to start
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
	LastServiceErrorId pulumi.StringInput `pulumi:"lastServiceErrorId"`
	// The ids of the layers the instance will belong to.
	LayerIds pulumi.StringArrayInput `pulumi:"layerIds"`
	// Name of operating system that will be installed.
	Os pulumi.StringInput `pulumi:"os"`
	Platform pulumi.StringInput `pulumi:"platform"`
	// The private DNS name assigned to the instance. Can only be
	// used inside the Amazon EC2, and only available if you've enabled DNS hostnames
	// for your VPC
	PrivateDns pulumi.StringInput `pulumi:"privateDns"`
	// The private IP address assigned to the instance
	PrivateIp pulumi.StringInput `pulumi:"privateIp"`
	// The public DNS name assigned to the instance. For EC2-VPC, this
	// is only available if you've enabled DNS hostnames for your VPC
	PublicDns pulumi.StringInput `pulumi:"publicDns"`
	// The public IP address assigned to the instance, if applicable.
	PublicIp pulumi.StringInput `pulumi:"publicIp"`
	RegisteredBy pulumi.StringInput `pulumi:"registeredBy"`
	ReportedAgentVersion pulumi.StringInput `pulumi:"reportedAgentVersion"`
	ReportedOsFamily pulumi.StringInput `pulumi:"reportedOsFamily"`
	ReportedOsName pulumi.StringInput `pulumi:"reportedOsName"`
	ReportedOsVersion pulumi.StringInput `pulumi:"reportedOsVersion"`
	// Customize details about the root block
	// device of the instance. See Block Devices below for details.
	RootBlockDevices InstanceRootBlockDevicesArrayInput `pulumi:"rootBlockDevices"`
	// Name of the type of root device instances will have by default.  Can be either `"ebs"` or `"instance-store"`
	RootDeviceType pulumi.StringInput `pulumi:"rootDeviceType"`
	RootDeviceVolumeId pulumi.StringInput `pulumi:"rootDeviceVolumeId"`
	// The associated security groups.
	SecurityGroupIds pulumi.StringArrayInput `pulumi:"securityGroupIds"`
	SshHostDsaKeyFingerprint pulumi.StringInput `pulumi:"sshHostDsaKeyFingerprint"`
	SshHostRsaKeyFingerprint pulumi.StringInput `pulumi:"sshHostRsaKeyFingerprint"`
	// Name of the SSH keypair that instances will have by default.
	SshKeyName pulumi.StringInput `pulumi:"sshKeyName"`
	// The id of the stack the instance will belong to.
	StackId pulumi.StringInput `pulumi:"stackId"`
	// The desired state of the instance.  Can be either `"running"` or `"stopped"`.
	State pulumi.StringInput `pulumi:"state"`
	Status pulumi.StringInput `pulumi:"status"`
	// Subnet ID to attach to
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
	// Instance tenancy to use. Can be one of `"default"`, `"dedicated"` or `"host"`
	Tenancy pulumi.StringInput `pulumi:"tenancy"`
	// Keyword to choose what virtualization mode created instances
	// will use. Can be either `"paravirtual"` or `"hvm"`.
	VirtualizationType pulumi.StringInput `pulumi:"virtualizationType"`
}
type InstanceEbsBlockDevices struct {
	DeleteOnTermination *bool `pulumi:"deleteOnTermination"`
	DeviceName string `pulumi:"deviceName"`
	Iops *int `pulumi:"iops"`
	SnapshotId *string `pulumi:"snapshotId"`
	VolumeSize *int `pulumi:"volumeSize"`
	VolumeType *string `pulumi:"volumeType"`
}
var instanceEbsBlockDevicesType = reflect.TypeOf((*InstanceEbsBlockDevices)(nil)).Elem()

type InstanceEbsBlockDevicesInput interface {
	pulumi.Input

	ToInstanceEbsBlockDevicesOutput() InstanceEbsBlockDevicesOutput
	ToInstanceEbsBlockDevicesOutputWithContext(ctx context.Context) InstanceEbsBlockDevicesOutput
}

type InstanceEbsBlockDevicesArgs struct {
	DeleteOnTermination pulumi.BoolInput `pulumi:"deleteOnTermination"`
	DeviceName pulumi.StringInput `pulumi:"deviceName"`
	Iops pulumi.IntInput `pulumi:"iops"`
	SnapshotId pulumi.StringInput `pulumi:"snapshotId"`
	VolumeSize pulumi.IntInput `pulumi:"volumeSize"`
	VolumeType pulumi.StringInput `pulumi:"volumeType"`
}

func (InstanceEbsBlockDevicesArgs) ElementType() reflect.Type {
	return instanceEbsBlockDevicesType
}

func (a InstanceEbsBlockDevicesArgs) ToInstanceEbsBlockDevicesOutput() InstanceEbsBlockDevicesOutput {
	return pulumi.ToOutput(a).(InstanceEbsBlockDevicesOutput)
}

func (a InstanceEbsBlockDevicesArgs) ToInstanceEbsBlockDevicesOutputWithContext(ctx context.Context) InstanceEbsBlockDevicesOutput {
	return pulumi.ToOutputWithContext(ctx, a).(InstanceEbsBlockDevicesOutput)
}

type InstanceEbsBlockDevicesOutput struct { *pulumi.OutputState }

func (o InstanceEbsBlockDevicesOutput) DeleteOnTermination() pulumi.BoolOutput {
	return o.Apply(func(v InstanceEbsBlockDevices) bool {
		if v.DeleteOnTermination == nil { return *new(bool) } else { return *v.DeleteOnTermination }
	}).(pulumi.BoolOutput)
}

func (o InstanceEbsBlockDevicesOutput) DeviceName() pulumi.StringOutput {
	return o.Apply(func(v InstanceEbsBlockDevices) string {
		return v.DeviceName
	}).(pulumi.StringOutput)
}

func (o InstanceEbsBlockDevicesOutput) Iops() pulumi.IntOutput {
	return o.Apply(func(v InstanceEbsBlockDevices) int {
		if v.Iops == nil { return *new(int) } else { return *v.Iops }
	}).(pulumi.IntOutput)
}

func (o InstanceEbsBlockDevicesOutput) SnapshotId() pulumi.StringOutput {
	return o.Apply(func(v InstanceEbsBlockDevices) string {
		if v.SnapshotId == nil { return *new(string) } else { return *v.SnapshotId }
	}).(pulumi.StringOutput)
}

func (o InstanceEbsBlockDevicesOutput) VolumeSize() pulumi.IntOutput {
	return o.Apply(func(v InstanceEbsBlockDevices) int {
		if v.VolumeSize == nil { return *new(int) } else { return *v.VolumeSize }
	}).(pulumi.IntOutput)
}

func (o InstanceEbsBlockDevicesOutput) VolumeType() pulumi.StringOutput {
	return o.Apply(func(v InstanceEbsBlockDevices) string {
		if v.VolumeType == nil { return *new(string) } else { return *v.VolumeType }
	}).(pulumi.StringOutput)
}

func (InstanceEbsBlockDevicesOutput) ElementType() reflect.Type {
	return instanceEbsBlockDevicesType
}

func (o InstanceEbsBlockDevicesOutput) ToInstanceEbsBlockDevicesOutput() InstanceEbsBlockDevicesOutput {
	return o
}

func (o InstanceEbsBlockDevicesOutput) ToInstanceEbsBlockDevicesOutputWithContext(ctx context.Context) InstanceEbsBlockDevicesOutput {
	return o
}

func init() { pulumi.RegisterOutputType(InstanceEbsBlockDevicesOutput{}) }

var instanceEbsBlockDevicesArrayType = reflect.TypeOf((*[]InstanceEbsBlockDevices)(nil)).Elem()

type InstanceEbsBlockDevicesArrayInput interface {
	pulumi.Input

	ToInstanceEbsBlockDevicesArrayOutput() InstanceEbsBlockDevicesArrayOutput
	ToInstanceEbsBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceEbsBlockDevicesArrayOutput
}

type InstanceEbsBlockDevicesArrayArgs []InstanceEbsBlockDevicesInput

func (InstanceEbsBlockDevicesArrayArgs) ElementType() reflect.Type {
	return instanceEbsBlockDevicesArrayType
}

func (a InstanceEbsBlockDevicesArrayArgs) ToInstanceEbsBlockDevicesArrayOutput() InstanceEbsBlockDevicesArrayOutput {
	return pulumi.ToOutput(a).(InstanceEbsBlockDevicesArrayOutput)
}

func (a InstanceEbsBlockDevicesArrayArgs) ToInstanceEbsBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceEbsBlockDevicesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(InstanceEbsBlockDevicesArrayOutput)
}

type InstanceEbsBlockDevicesArrayOutput struct { *pulumi.OutputState }

func (o InstanceEbsBlockDevicesArrayOutput) Index(i pulumi.IntInput) InstanceEbsBlockDevicesOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) InstanceEbsBlockDevices {
		return vs[0].([]InstanceEbsBlockDevices)[vs[1].(int)]
	}).(InstanceEbsBlockDevicesOutput)
}

func (InstanceEbsBlockDevicesArrayOutput) ElementType() reflect.Type {
	return instanceEbsBlockDevicesArrayType
}

func (o InstanceEbsBlockDevicesArrayOutput) ToInstanceEbsBlockDevicesArrayOutput() InstanceEbsBlockDevicesArrayOutput {
	return o
}

func (o InstanceEbsBlockDevicesArrayOutput) ToInstanceEbsBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceEbsBlockDevicesArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(InstanceEbsBlockDevicesArrayOutput{}) }

type InstanceEphemeralBlockDevices struct {
	DeviceName string `pulumi:"deviceName"`
	VirtualName string `pulumi:"virtualName"`
}
var instanceEphemeralBlockDevicesType = reflect.TypeOf((*InstanceEphemeralBlockDevices)(nil)).Elem()

type InstanceEphemeralBlockDevicesInput interface {
	pulumi.Input

	ToInstanceEphemeralBlockDevicesOutput() InstanceEphemeralBlockDevicesOutput
	ToInstanceEphemeralBlockDevicesOutputWithContext(ctx context.Context) InstanceEphemeralBlockDevicesOutput
}

type InstanceEphemeralBlockDevicesArgs struct {
	DeviceName pulumi.StringInput `pulumi:"deviceName"`
	VirtualName pulumi.StringInput `pulumi:"virtualName"`
}

func (InstanceEphemeralBlockDevicesArgs) ElementType() reflect.Type {
	return instanceEphemeralBlockDevicesType
}

func (a InstanceEphemeralBlockDevicesArgs) ToInstanceEphemeralBlockDevicesOutput() InstanceEphemeralBlockDevicesOutput {
	return pulumi.ToOutput(a).(InstanceEphemeralBlockDevicesOutput)
}

func (a InstanceEphemeralBlockDevicesArgs) ToInstanceEphemeralBlockDevicesOutputWithContext(ctx context.Context) InstanceEphemeralBlockDevicesOutput {
	return pulumi.ToOutputWithContext(ctx, a).(InstanceEphemeralBlockDevicesOutput)
}

type InstanceEphemeralBlockDevicesOutput struct { *pulumi.OutputState }

func (o InstanceEphemeralBlockDevicesOutput) DeviceName() pulumi.StringOutput {
	return o.Apply(func(v InstanceEphemeralBlockDevices) string {
		return v.DeviceName
	}).(pulumi.StringOutput)
}

func (o InstanceEphemeralBlockDevicesOutput) VirtualName() pulumi.StringOutput {
	return o.Apply(func(v InstanceEphemeralBlockDevices) string {
		return v.VirtualName
	}).(pulumi.StringOutput)
}

func (InstanceEphemeralBlockDevicesOutput) ElementType() reflect.Type {
	return instanceEphemeralBlockDevicesType
}

func (o InstanceEphemeralBlockDevicesOutput) ToInstanceEphemeralBlockDevicesOutput() InstanceEphemeralBlockDevicesOutput {
	return o
}

func (o InstanceEphemeralBlockDevicesOutput) ToInstanceEphemeralBlockDevicesOutputWithContext(ctx context.Context) InstanceEphemeralBlockDevicesOutput {
	return o
}

func init() { pulumi.RegisterOutputType(InstanceEphemeralBlockDevicesOutput{}) }

var instanceEphemeralBlockDevicesArrayType = reflect.TypeOf((*[]InstanceEphemeralBlockDevices)(nil)).Elem()

type InstanceEphemeralBlockDevicesArrayInput interface {
	pulumi.Input

	ToInstanceEphemeralBlockDevicesArrayOutput() InstanceEphemeralBlockDevicesArrayOutput
	ToInstanceEphemeralBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceEphemeralBlockDevicesArrayOutput
}

type InstanceEphemeralBlockDevicesArrayArgs []InstanceEphemeralBlockDevicesInput

func (InstanceEphemeralBlockDevicesArrayArgs) ElementType() reflect.Type {
	return instanceEphemeralBlockDevicesArrayType
}

func (a InstanceEphemeralBlockDevicesArrayArgs) ToInstanceEphemeralBlockDevicesArrayOutput() InstanceEphemeralBlockDevicesArrayOutput {
	return pulumi.ToOutput(a).(InstanceEphemeralBlockDevicesArrayOutput)
}

func (a InstanceEphemeralBlockDevicesArrayArgs) ToInstanceEphemeralBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceEphemeralBlockDevicesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(InstanceEphemeralBlockDevicesArrayOutput)
}

type InstanceEphemeralBlockDevicesArrayOutput struct { *pulumi.OutputState }

func (o InstanceEphemeralBlockDevicesArrayOutput) Index(i pulumi.IntInput) InstanceEphemeralBlockDevicesOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) InstanceEphemeralBlockDevices {
		return vs[0].([]InstanceEphemeralBlockDevices)[vs[1].(int)]
	}).(InstanceEphemeralBlockDevicesOutput)
}

func (InstanceEphemeralBlockDevicesArrayOutput) ElementType() reflect.Type {
	return instanceEphemeralBlockDevicesArrayType
}

func (o InstanceEphemeralBlockDevicesArrayOutput) ToInstanceEphemeralBlockDevicesArrayOutput() InstanceEphemeralBlockDevicesArrayOutput {
	return o
}

func (o InstanceEphemeralBlockDevicesArrayOutput) ToInstanceEphemeralBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceEphemeralBlockDevicesArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(InstanceEphemeralBlockDevicesArrayOutput{}) }

type InstanceRootBlockDevices struct {
	DeleteOnTermination *bool `pulumi:"deleteOnTermination"`
	Iops *int `pulumi:"iops"`
	VolumeSize *int `pulumi:"volumeSize"`
	VolumeType *string `pulumi:"volumeType"`
}
var instanceRootBlockDevicesType = reflect.TypeOf((*InstanceRootBlockDevices)(nil)).Elem()

type InstanceRootBlockDevicesInput interface {
	pulumi.Input

	ToInstanceRootBlockDevicesOutput() InstanceRootBlockDevicesOutput
	ToInstanceRootBlockDevicesOutputWithContext(ctx context.Context) InstanceRootBlockDevicesOutput
}

type InstanceRootBlockDevicesArgs struct {
	DeleteOnTermination pulumi.BoolInput `pulumi:"deleteOnTermination"`
	Iops pulumi.IntInput `pulumi:"iops"`
	VolumeSize pulumi.IntInput `pulumi:"volumeSize"`
	VolumeType pulumi.StringInput `pulumi:"volumeType"`
}

func (InstanceRootBlockDevicesArgs) ElementType() reflect.Type {
	return instanceRootBlockDevicesType
}

func (a InstanceRootBlockDevicesArgs) ToInstanceRootBlockDevicesOutput() InstanceRootBlockDevicesOutput {
	return pulumi.ToOutput(a).(InstanceRootBlockDevicesOutput)
}

func (a InstanceRootBlockDevicesArgs) ToInstanceRootBlockDevicesOutputWithContext(ctx context.Context) InstanceRootBlockDevicesOutput {
	return pulumi.ToOutputWithContext(ctx, a).(InstanceRootBlockDevicesOutput)
}

type InstanceRootBlockDevicesOutput struct { *pulumi.OutputState }

func (o InstanceRootBlockDevicesOutput) DeleteOnTermination() pulumi.BoolOutput {
	return o.Apply(func(v InstanceRootBlockDevices) bool {
		if v.DeleteOnTermination == nil { return *new(bool) } else { return *v.DeleteOnTermination }
	}).(pulumi.BoolOutput)
}

func (o InstanceRootBlockDevicesOutput) Iops() pulumi.IntOutput {
	return o.Apply(func(v InstanceRootBlockDevices) int {
		if v.Iops == nil { return *new(int) } else { return *v.Iops }
	}).(pulumi.IntOutput)
}

func (o InstanceRootBlockDevicesOutput) VolumeSize() pulumi.IntOutput {
	return o.Apply(func(v InstanceRootBlockDevices) int {
		if v.VolumeSize == nil { return *new(int) } else { return *v.VolumeSize }
	}).(pulumi.IntOutput)
}

func (o InstanceRootBlockDevicesOutput) VolumeType() pulumi.StringOutput {
	return o.Apply(func(v InstanceRootBlockDevices) string {
		if v.VolumeType == nil { return *new(string) } else { return *v.VolumeType }
	}).(pulumi.StringOutput)
}

func (InstanceRootBlockDevicesOutput) ElementType() reflect.Type {
	return instanceRootBlockDevicesType
}

func (o InstanceRootBlockDevicesOutput) ToInstanceRootBlockDevicesOutput() InstanceRootBlockDevicesOutput {
	return o
}

func (o InstanceRootBlockDevicesOutput) ToInstanceRootBlockDevicesOutputWithContext(ctx context.Context) InstanceRootBlockDevicesOutput {
	return o
}

func init() { pulumi.RegisterOutputType(InstanceRootBlockDevicesOutput{}) }

var instanceRootBlockDevicesArrayType = reflect.TypeOf((*[]InstanceRootBlockDevices)(nil)).Elem()

type InstanceRootBlockDevicesArrayInput interface {
	pulumi.Input

	ToInstanceRootBlockDevicesArrayOutput() InstanceRootBlockDevicesArrayOutput
	ToInstanceRootBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceRootBlockDevicesArrayOutput
}

type InstanceRootBlockDevicesArrayArgs []InstanceRootBlockDevicesInput

func (InstanceRootBlockDevicesArrayArgs) ElementType() reflect.Type {
	return instanceRootBlockDevicesArrayType
}

func (a InstanceRootBlockDevicesArrayArgs) ToInstanceRootBlockDevicesArrayOutput() InstanceRootBlockDevicesArrayOutput {
	return pulumi.ToOutput(a).(InstanceRootBlockDevicesArrayOutput)
}

func (a InstanceRootBlockDevicesArrayArgs) ToInstanceRootBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceRootBlockDevicesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(InstanceRootBlockDevicesArrayOutput)
}

type InstanceRootBlockDevicesArrayOutput struct { *pulumi.OutputState }

func (o InstanceRootBlockDevicesArrayOutput) Index(i pulumi.IntInput) InstanceRootBlockDevicesOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) InstanceRootBlockDevices {
		return vs[0].([]InstanceRootBlockDevices)[vs[1].(int)]
	}).(InstanceRootBlockDevicesOutput)
}

func (InstanceRootBlockDevicesArrayOutput) ElementType() reflect.Type {
	return instanceRootBlockDevicesArrayType
}

func (o InstanceRootBlockDevicesArrayOutput) ToInstanceRootBlockDevicesArrayOutput() InstanceRootBlockDevicesArrayOutput {
	return o
}

func (o InstanceRootBlockDevicesArrayOutput) ToInstanceRootBlockDevicesArrayOutputWithContext(ctx context.Context) InstanceRootBlockDevicesArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(InstanceRootBlockDevicesArrayOutput{}) }

