// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package autoscaling

import (
	"context"
	"reflect"
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides an AutoScaling Group resource.
// 
// > **Note:** You must specify either `launchConfiguration`, `launchTemplate`, or `mixedInstancesPolicy`.
// 
// ## Waiting for Capacity
// 
// A newly-created ASG is initially empty and begins to scale to `minSize` (or
// `desiredCapacity`, if specified) by launching instances using the provided
// Launch Configuration. These instances take time to launch and boot.
// 
// On ASG Update, changes to these values also take time to result in the target
// number of instances providing service.
// 
// This provider provides two mechanisms to help consistently manage ASG scale up
// time across dependent resources.
// 
// #### Waiting for ASG Capacity
// 
// The first is default behavior. This provider waits after ASG creation for
// `minSize` (or `desiredCapacity`, if specified) healthy instances to show up
// in the ASG before continuing.
// 
// If `minSize` or `desiredCapacity` are changed in a subsequent update,
// this provider will also wait for the correct number of healthy instances before
// continuing.
// 
// This provider considers an instance "healthy" when the ASG reports `HealthStatus:
// "Healthy"` and `LifecycleState: "InService"`. See the [AWS AutoScaling
// Docs](https://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/AutoScalingGroupLifecycle.html)
// for more information on an ASG's lifecycle.
// 
// This provider will wait for healthy instances for up to
// `waitForCapacityTimeout`. If ASG creation is taking more than a few minutes,
// it's worth investigating for scaling activity errors, which can be caused by
// problems with the selected Launch Configuration.
// 
// Setting `waitForCapacityTimeout` to `"0"` disables ASG Capacity waiting.
// 
// #### Waiting for ELB Capacity
// 
// The second mechanism is optional, and affects ASGs with attached ELBs specified
// via the `loadBalancers` attribute or with ALBs specified with `targetGroupArns`.
// 
// The `minElbCapacity` parameter causes this provider to wait for at least the
// requested number of instances to show up `"InService"` in all attached ELBs
// during ASG creation.  It has no effect on ASG updates.
// 
// If `waitForElbCapacity` is set, this provider will wait for exactly that number
// of Instances to be `"InService"` in all attached ELBs on both creation and
// updates.
// 
// These parameters can be used to ensure that service is being provided before
// this provider moves on. If new instances don't pass the ELB's health checks for any
// reason, the deployment will time out, and the ASG will be marked as
// tainted (i.e. marked to be destroyed in a follow up run).
// 
// As with ASG Capacity, this provider will wait for up to `waitForCapacityTimeout`
// for the proper number of instances to be healthy.
// 
// #### Troubleshooting Capacity Waiting Timeouts
// 
// If ASG creation takes more than a few minutes, this could indicate one of a
// number of configuration problems. See the [AWS Docs on Load Balancer
// Troubleshooting](https://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-troubleshooting.html)
// for more information.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/autoscaling_group.html.markdown.
type Group struct {
	pulumi.CustomResourceState

	// The ARN for this AutoScaling Group
	Arn pulumi.StringOutput `pulumi:"arn"`

	// A list of one or more availability zones for the group. This parameter should not be specified when using `vpcZoneIdentifier`.
	AvailabilityZones pulumi.StringArrayOutput `pulumi:"availabilityZones"`

	// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
	DefaultCooldown pulumi.IntOutput `pulumi:"defaultCooldown"`

	// The number of Amazon EC2 instances that
	// should be running in the group. (See also Waiting for
	// Capacity below.)
	DesiredCapacity pulumi.IntOutput `pulumi:"desiredCapacity"`

	// A list of metrics to collect. The allowed values are `GroupMinSize`, `GroupMaxSize`, `GroupDesiredCapacity`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupTerminatingInstances`, `GroupTotalInstances`.
	// * `waitForCapacityTimeout` (Default: "10m") A maximum
	// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
	// wait for ASG instances to be healthy before timing out.  (See also Waiting
	// for Capacity below.) Setting this to "0" causes
	// this provider to skip all Capacity Waiting behavior.
	EnabledMetrics pulumi.StringArrayOutput `pulumi:"enabledMetrics"`

	// Allows deleting the autoscaling group without waiting
	// for all instances in the pool to terminate.  You can force an autoscaling group to delete
	// even if it's in the process of scaling a resource. Normally, this provider
	// drains all the instances before deleting the group.  This bypasses that
	// behavior and potentially leaves resources dangling.
	ForceDelete pulumi.BoolOutput `pulumi:"forceDelete"`

	// Time (in seconds) after instance comes into service before checking health.
	HealthCheckGracePeriod pulumi.IntOutput `pulumi:"healthCheckGracePeriod"`

	// "EC2" or "ELB". Controls how health checking is done.
	HealthCheckType pulumi.StringOutput `pulumi:"healthCheckType"`

	// One or more
	// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
	// to attach to the autoscaling group **before** instances are launched. The
	// syntax is exactly the same as the separate
	// [`autoscaling.LifecycleHook`](https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hooks.html)
	// resource, without the `autoscalingGroupName` attribute. Please note that this will only work when creating
	// a new autoscaling group. For all other use-cases, please use `autoscaling.LifecycleHook` resource.
	InitialLifecycleHooks GroupInitialLifecycleHooksArrayOutput `pulumi:"initialLifecycleHooks"`

	// The name of the launch configuration to use.
	LaunchConfiguration pulumi.StringOutput `pulumi:"launchConfiguration"`

	// Nested argument containing launch template settings along with the overrides to specify multiple instance types. Defined below.
	LaunchTemplate GroupLaunchTemplateOutput `pulumi:"launchTemplate"`

	// A list of elastic load balancer names to add to the autoscaling
	// group names. Only valid for classic load balancers. For ALBs, use `targetGroupArns` instead.
	LoadBalancers pulumi.StringArrayOutput `pulumi:"loadBalancers"`

	// The maximum size of the auto scale group.
	MaxSize pulumi.IntOutput `pulumi:"maxSize"`

	// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
	MetricsGranularity pulumi.StringOutput `pulumi:"metricsGranularity"`

	// Setting this causes this provider to wait for
	// this number of instances from this autoscaling group to show up healthy in the
	// ELB only on creation. Updates will not wait on ELB instance number changes.
	// (See also Waiting for Capacity below.)
	MinElbCapacity pulumi.IntOutput `pulumi:"minElbCapacity"`

	// The minimum size of the auto scale group.
	// (See also Waiting for Capacity below.)
	MinSize pulumi.IntOutput `pulumi:"minSize"`

	// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
	MixedInstancesPolicy GroupMixedInstancesPolicyOutput `pulumi:"mixedInstancesPolicy"`

	// The name of the auto scaling group. By default generated by this provider.
	Name pulumi.StringOutput `pulumi:"name"`

	// Creates a unique name beginning with the specified
	// prefix. Conflicts with `name`.
	NamePrefix pulumi.StringOutput `pulumi:"namePrefix"`

	// The name of the placement group into which you'll launch your instances, if any.
	PlacementGroup pulumi.StringOutput `pulumi:"placementGroup"`

	// Allows setting instance protection. The
	// autoscaling group will not select instances with this setting for terminination
	// during scale in events.
	ProtectFromScaleIn pulumi.BoolOutput `pulumi:"protectFromScaleIn"`

	// The ARN of the service-linked role that the ASG will use to call other AWS services
	ServiceLinkedRoleArn pulumi.StringOutput `pulumi:"serviceLinkedRoleArn"`

	// A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
	// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
	SuspendedProcesses pulumi.StringArrayOutput `pulumi:"suspendedProcesses"`

	// A list of tag blocks. Tags documented below.
	Tags GroupTagsArrayOutput `pulumi:"tags"`

	// A list of tag blocks (maps). Tags documented below.
	TagsCollection pulumi.ArrayOutput `pulumi:"tagsCollection"`

	// A list of `alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
	TargetGroupArns pulumi.StringArrayOutput `pulumi:"targetGroupArns"`

	// A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
	TerminationPolicies pulumi.StringArrayOutput `pulumi:"terminationPolicies"`

	// A list of subnet IDs to launch resources in.
	VpcZoneIdentifiers pulumi.StringArrayOutput `pulumi:"vpcZoneIdentifiers"`

	WaitForCapacityTimeout pulumi.StringOutput `pulumi:"waitForCapacityTimeout"`

	// Setting this will cause this provider to wait
	// for exactly this number of healthy instances from this autoscaling group in
	// all attached load balancers on both create and update operations. (Takes
	// precedence over `minElbCapacity` behavior.)
	// (See also Waiting for Capacity below.)
	WaitForElbCapacity pulumi.IntOutput `pulumi:"waitForElbCapacity"`
}

// NewGroup registers a new resource with the given unique name, arguments, and options.
func NewGroup(ctx *pulumi.Context,
	name string, args *GroupArgs, opts ...pulumi.ResourceOption) (*Group, error) {
	if args == nil || args.MaxSize == nil {
		return nil, errors.New("missing required argument 'MaxSize'")
	}
	if args == nil || args.MinSize == nil {
		return nil, errors.New("missing required argument 'MinSize'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.AvailabilityZones; i != nil { inputs["availabilityZones"] = i.ToStringArrayOutput() }
		if i := args.DefaultCooldown; i != nil { inputs["defaultCooldown"] = i.ToIntOutput() }
		if i := args.DesiredCapacity; i != nil { inputs["desiredCapacity"] = i.ToIntOutput() }
		if i := args.EnabledMetrics; i != nil { inputs["enabledMetrics"] = i.ToStringArrayOutput() }
		if i := args.ForceDelete; i != nil { inputs["forceDelete"] = i.ToBoolOutput() }
		if i := args.HealthCheckGracePeriod; i != nil { inputs["healthCheckGracePeriod"] = i.ToIntOutput() }
		if i := args.HealthCheckType; i != nil { inputs["healthCheckType"] = i.ToStringOutput() }
		if i := args.InitialLifecycleHooks; i != nil { inputs["initialLifecycleHooks"] = i.ToGroupInitialLifecycleHooksArrayOutput() }
		if i := args.LaunchConfiguration; i != nil { inputs["launchConfiguration"] = i.ToStringOutput() }
		if i := args.LaunchTemplate; i != nil { inputs["launchTemplate"] = i.ToGroupLaunchTemplateOutput() }
		if i := args.LoadBalancers; i != nil { inputs["loadBalancers"] = i.ToStringArrayOutput() }
		if i := args.MaxSize; i != nil { inputs["maxSize"] = i.ToIntOutput() }
		if i := args.MetricsGranularity; i != nil { inputs["metricsGranularity"] = i.ToStringOutput() }
		if i := args.MinElbCapacity; i != nil { inputs["minElbCapacity"] = i.ToIntOutput() }
		if i := args.MinSize; i != nil { inputs["minSize"] = i.ToIntOutput() }
		if i := args.MixedInstancesPolicy; i != nil { inputs["mixedInstancesPolicy"] = i.ToGroupMixedInstancesPolicyOutput() }
		if i := args.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := args.NamePrefix; i != nil { inputs["namePrefix"] = i.ToStringOutput() }
		if i := args.PlacementGroup; i != nil { inputs["placementGroup"] = i.ToStringOutput() }
		if i := args.ProtectFromScaleIn; i != nil { inputs["protectFromScaleIn"] = i.ToBoolOutput() }
		if i := args.ServiceLinkedRoleArn; i != nil { inputs["serviceLinkedRoleArn"] = i.ToStringOutput() }
		if i := args.SuspendedProcesses; i != nil { inputs["suspendedProcesses"] = i.ToStringArrayOutput() }
		if i := args.Tags; i != nil { inputs["tags"] = i.ToGroupTagsArrayOutput() }
		if i := args.TagsCollection; i != nil { inputs["tagsCollection"] = i.ToArrayOutput() }
		if i := args.TargetGroupArns; i != nil { inputs["targetGroupArns"] = i.ToStringArrayOutput() }
		if i := args.TerminationPolicies; i != nil { inputs["terminationPolicies"] = i.ToStringArrayOutput() }
		if i := args.VpcZoneIdentifiers; i != nil { inputs["vpcZoneIdentifiers"] = i.ToStringArrayOutput() }
		if i := args.WaitForCapacityTimeout; i != nil { inputs["waitForCapacityTimeout"] = i.ToStringOutput() }
		if i := args.WaitForElbCapacity; i != nil { inputs["waitForElbCapacity"] = i.ToIntOutput() }
	}
	var resource Group
	err := ctx.RegisterResource("aws:autoscaling/group:Group", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGroup gets an existing Group resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GroupState, opts ...pulumi.ResourceOption) (*Group, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.Arn; i != nil { inputs["arn"] = i.ToStringOutput() }
		if i := state.AvailabilityZones; i != nil { inputs["availabilityZones"] = i.ToStringArrayOutput() }
		if i := state.DefaultCooldown; i != nil { inputs["defaultCooldown"] = i.ToIntOutput() }
		if i := state.DesiredCapacity; i != nil { inputs["desiredCapacity"] = i.ToIntOutput() }
		if i := state.EnabledMetrics; i != nil { inputs["enabledMetrics"] = i.ToStringArrayOutput() }
		if i := state.ForceDelete; i != nil { inputs["forceDelete"] = i.ToBoolOutput() }
		if i := state.HealthCheckGracePeriod; i != nil { inputs["healthCheckGracePeriod"] = i.ToIntOutput() }
		if i := state.HealthCheckType; i != nil { inputs["healthCheckType"] = i.ToStringOutput() }
		if i := state.InitialLifecycleHooks; i != nil { inputs["initialLifecycleHooks"] = i.ToGroupInitialLifecycleHooksArrayOutput() }
		if i := state.LaunchConfiguration; i != nil { inputs["launchConfiguration"] = i.ToStringOutput() }
		if i := state.LaunchTemplate; i != nil { inputs["launchTemplate"] = i.ToGroupLaunchTemplateOutput() }
		if i := state.LoadBalancers; i != nil { inputs["loadBalancers"] = i.ToStringArrayOutput() }
		if i := state.MaxSize; i != nil { inputs["maxSize"] = i.ToIntOutput() }
		if i := state.MetricsGranularity; i != nil { inputs["metricsGranularity"] = i.ToStringOutput() }
		if i := state.MinElbCapacity; i != nil { inputs["minElbCapacity"] = i.ToIntOutput() }
		if i := state.MinSize; i != nil { inputs["minSize"] = i.ToIntOutput() }
		if i := state.MixedInstancesPolicy; i != nil { inputs["mixedInstancesPolicy"] = i.ToGroupMixedInstancesPolicyOutput() }
		if i := state.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := state.NamePrefix; i != nil { inputs["namePrefix"] = i.ToStringOutput() }
		if i := state.PlacementGroup; i != nil { inputs["placementGroup"] = i.ToStringOutput() }
		if i := state.ProtectFromScaleIn; i != nil { inputs["protectFromScaleIn"] = i.ToBoolOutput() }
		if i := state.ServiceLinkedRoleArn; i != nil { inputs["serviceLinkedRoleArn"] = i.ToStringOutput() }
		if i := state.SuspendedProcesses; i != nil { inputs["suspendedProcesses"] = i.ToStringArrayOutput() }
		if i := state.Tags; i != nil { inputs["tags"] = i.ToGroupTagsArrayOutput() }
		if i := state.TagsCollection; i != nil { inputs["tagsCollection"] = i.ToArrayOutput() }
		if i := state.TargetGroupArns; i != nil { inputs["targetGroupArns"] = i.ToStringArrayOutput() }
		if i := state.TerminationPolicies; i != nil { inputs["terminationPolicies"] = i.ToStringArrayOutput() }
		if i := state.VpcZoneIdentifiers; i != nil { inputs["vpcZoneIdentifiers"] = i.ToStringArrayOutput() }
		if i := state.WaitForCapacityTimeout; i != nil { inputs["waitForCapacityTimeout"] = i.ToStringOutput() }
		if i := state.WaitForElbCapacity; i != nil { inputs["waitForElbCapacity"] = i.ToIntOutput() }
	}
	var resource Group
	err := ctx.ReadResource("aws:autoscaling/group:Group", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Group resources.
type GroupState struct {
	// The ARN for this AutoScaling Group
	Arn pulumi.StringInput `pulumi:"arn"`
	// A list of one or more availability zones for the group. This parameter should not be specified when using `vpcZoneIdentifier`.
	AvailabilityZones pulumi.StringArrayInput `pulumi:"availabilityZones"`
	// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
	DefaultCooldown pulumi.IntInput `pulumi:"defaultCooldown"`
	// The number of Amazon EC2 instances that
	// should be running in the group. (See also Waiting for
	// Capacity below.)
	DesiredCapacity pulumi.IntInput `pulumi:"desiredCapacity"`
	// A list of metrics to collect. The allowed values are `GroupMinSize`, `GroupMaxSize`, `GroupDesiredCapacity`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupTerminatingInstances`, `GroupTotalInstances`.
	// * `waitForCapacityTimeout` (Default: "10m") A maximum
	// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
	// wait for ASG instances to be healthy before timing out.  (See also Waiting
	// for Capacity below.) Setting this to "0" causes
	// this provider to skip all Capacity Waiting behavior.
	EnabledMetrics pulumi.StringArrayInput `pulumi:"enabledMetrics"`
	// Allows deleting the autoscaling group without waiting
	// for all instances in the pool to terminate.  You can force an autoscaling group to delete
	// even if it's in the process of scaling a resource. Normally, this provider
	// drains all the instances before deleting the group.  This bypasses that
	// behavior and potentially leaves resources dangling.
	ForceDelete pulumi.BoolInput `pulumi:"forceDelete"`
	// Time (in seconds) after instance comes into service before checking health.
	HealthCheckGracePeriod pulumi.IntInput `pulumi:"healthCheckGracePeriod"`
	// "EC2" or "ELB". Controls how health checking is done.
	HealthCheckType pulumi.StringInput `pulumi:"healthCheckType"`
	// One or more
	// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
	// to attach to the autoscaling group **before** instances are launched. The
	// syntax is exactly the same as the separate
	// [`autoscaling.LifecycleHook`](https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hooks.html)
	// resource, without the `autoscalingGroupName` attribute. Please note that this will only work when creating
	// a new autoscaling group. For all other use-cases, please use `autoscaling.LifecycleHook` resource.
	InitialLifecycleHooks GroupInitialLifecycleHooksArrayInput `pulumi:"initialLifecycleHooks"`
	// The name of the launch configuration to use.
	LaunchConfiguration pulumi.StringInput `pulumi:"launchConfiguration"`
	// Nested argument containing launch template settings along with the overrides to specify multiple instance types. Defined below.
	LaunchTemplate GroupLaunchTemplateInput `pulumi:"launchTemplate"`
	// A list of elastic load balancer names to add to the autoscaling
	// group names. Only valid for classic load balancers. For ALBs, use `targetGroupArns` instead.
	LoadBalancers pulumi.StringArrayInput `pulumi:"loadBalancers"`
	// The maximum size of the auto scale group.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
	MetricsGranularity pulumi.StringInput `pulumi:"metricsGranularity"`
	// Setting this causes this provider to wait for
	// this number of instances from this autoscaling group to show up healthy in the
	// ELB only on creation. Updates will not wait on ELB instance number changes.
	// (See also Waiting for Capacity below.)
	MinElbCapacity pulumi.IntInput `pulumi:"minElbCapacity"`
	// The minimum size of the auto scale group.
	// (See also Waiting for Capacity below.)
	MinSize pulumi.IntInput `pulumi:"minSize"`
	// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
	MixedInstancesPolicy GroupMixedInstancesPolicyInput `pulumi:"mixedInstancesPolicy"`
	// The name of the auto scaling group. By default generated by this provider.
	Name pulumi.StringInput `pulumi:"name"`
	// Creates a unique name beginning with the specified
	// prefix. Conflicts with `name`.
	NamePrefix pulumi.StringInput `pulumi:"namePrefix"`
	// The name of the placement group into which you'll launch your instances, if any.
	PlacementGroup pulumi.StringInput `pulumi:"placementGroup"`
	// Allows setting instance protection. The
	// autoscaling group will not select instances with this setting for terminination
	// during scale in events.
	ProtectFromScaleIn pulumi.BoolInput `pulumi:"protectFromScaleIn"`
	// The ARN of the service-linked role that the ASG will use to call other AWS services
	ServiceLinkedRoleArn pulumi.StringInput `pulumi:"serviceLinkedRoleArn"`
	// A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
	// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
	SuspendedProcesses pulumi.StringArrayInput `pulumi:"suspendedProcesses"`
	// A list of tag blocks. Tags documented below.
	Tags GroupTagsArrayInput `pulumi:"tags"`
	// A list of tag blocks (maps). Tags documented below.
	TagsCollection pulumi.ArrayInput `pulumi:"tagsCollection"`
	// A list of `alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
	TargetGroupArns pulumi.StringArrayInput `pulumi:"targetGroupArns"`
	// A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
	TerminationPolicies pulumi.StringArrayInput `pulumi:"terminationPolicies"`
	// A list of subnet IDs to launch resources in.
	VpcZoneIdentifiers pulumi.StringArrayInput `pulumi:"vpcZoneIdentifiers"`
	WaitForCapacityTimeout pulumi.StringInput `pulumi:"waitForCapacityTimeout"`
	// Setting this will cause this provider to wait
	// for exactly this number of healthy instances from this autoscaling group in
	// all attached load balancers on both create and update operations. (Takes
	// precedence over `minElbCapacity` behavior.)
	// (See also Waiting for Capacity below.)
	WaitForElbCapacity pulumi.IntInput `pulumi:"waitForElbCapacity"`
}

// The set of arguments for constructing a Group resource.
type GroupArgs struct {
	// A list of one or more availability zones for the group. This parameter should not be specified when using `vpcZoneIdentifier`.
	AvailabilityZones pulumi.StringArrayInput `pulumi:"availabilityZones"`
	// The amount of time, in seconds, after a scaling activity completes before another scaling activity can start.
	DefaultCooldown pulumi.IntInput `pulumi:"defaultCooldown"`
	// The number of Amazon EC2 instances that
	// should be running in the group. (See also Waiting for
	// Capacity below.)
	DesiredCapacity pulumi.IntInput `pulumi:"desiredCapacity"`
	// A list of metrics to collect. The allowed values are `GroupMinSize`, `GroupMaxSize`, `GroupDesiredCapacity`, `GroupInServiceInstances`, `GroupPendingInstances`, `GroupStandbyInstances`, `GroupTerminatingInstances`, `GroupTotalInstances`.
	// * `waitForCapacityTimeout` (Default: "10m") A maximum
	// [duration](https://golang.org/pkg/time/#ParseDuration) that this provider should
	// wait for ASG instances to be healthy before timing out.  (See also Waiting
	// for Capacity below.) Setting this to "0" causes
	// this provider to skip all Capacity Waiting behavior.
	EnabledMetrics pulumi.StringArrayInput `pulumi:"enabledMetrics"`
	// Allows deleting the autoscaling group without waiting
	// for all instances in the pool to terminate.  You can force an autoscaling group to delete
	// even if it's in the process of scaling a resource. Normally, this provider
	// drains all the instances before deleting the group.  This bypasses that
	// behavior and potentially leaves resources dangling.
	ForceDelete pulumi.BoolInput `pulumi:"forceDelete"`
	// Time (in seconds) after instance comes into service before checking health.
	HealthCheckGracePeriod pulumi.IntInput `pulumi:"healthCheckGracePeriod"`
	// "EC2" or "ELB". Controls how health checking is done.
	HealthCheckType pulumi.StringInput `pulumi:"healthCheckType"`
	// One or more
	// [Lifecycle Hooks](http://docs.aws.amazon.com/autoscaling/latest/userguide/lifecycle-hooks.html)
	// to attach to the autoscaling group **before** instances are launched. The
	// syntax is exactly the same as the separate
	// [`autoscaling.LifecycleHook`](https://www.terraform.io/docs/providers/aws/r/autoscaling_lifecycle_hooks.html)
	// resource, without the `autoscalingGroupName` attribute. Please note that this will only work when creating
	// a new autoscaling group. For all other use-cases, please use `autoscaling.LifecycleHook` resource.
	InitialLifecycleHooks GroupInitialLifecycleHooksArrayInput `pulumi:"initialLifecycleHooks"`
	// The name of the launch configuration to use.
	LaunchConfiguration pulumi.StringInput `pulumi:"launchConfiguration"`
	// Nested argument containing launch template settings along with the overrides to specify multiple instance types. Defined below.
	LaunchTemplate GroupLaunchTemplateInput `pulumi:"launchTemplate"`
	// A list of elastic load balancer names to add to the autoscaling
	// group names. Only valid for classic load balancers. For ALBs, use `targetGroupArns` instead.
	LoadBalancers pulumi.StringArrayInput `pulumi:"loadBalancers"`
	// The maximum size of the auto scale group.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The granularity to associate with the metrics to collect. The only valid value is `1Minute`. Default is `1Minute`.
	MetricsGranularity pulumi.StringInput `pulumi:"metricsGranularity"`
	// Setting this causes this provider to wait for
	// this number of instances from this autoscaling group to show up healthy in the
	// ELB only on creation. Updates will not wait on ELB instance number changes.
	// (See also Waiting for Capacity below.)
	MinElbCapacity pulumi.IntInput `pulumi:"minElbCapacity"`
	// The minimum size of the auto scale group.
	// (See also Waiting for Capacity below.)
	MinSize pulumi.IntInput `pulumi:"minSize"`
	// Configuration block containing settings to define launch targets for Auto Scaling groups. Defined below.
	MixedInstancesPolicy GroupMixedInstancesPolicyInput `pulumi:"mixedInstancesPolicy"`
	// The name of the auto scaling group. By default generated by this provider.
	Name pulumi.StringInput `pulumi:"name"`
	// Creates a unique name beginning with the specified
	// prefix. Conflicts with `name`.
	NamePrefix pulumi.StringInput `pulumi:"namePrefix"`
	// The name of the placement group into which you'll launch your instances, if any.
	PlacementGroup pulumi.StringInput `pulumi:"placementGroup"`
	// Allows setting instance protection. The
	// autoscaling group will not select instances with this setting for terminination
	// during scale in events.
	ProtectFromScaleIn pulumi.BoolInput `pulumi:"protectFromScaleIn"`
	// The ARN of the service-linked role that the ASG will use to call other AWS services
	ServiceLinkedRoleArn pulumi.StringInput `pulumi:"serviceLinkedRoleArn"`
	// A list of processes to suspend for the AutoScaling Group. The allowed values are `Launch`, `Terminate`, `HealthCheck`, `ReplaceUnhealthy`, `AZRebalance`, `AlarmNotification`, `ScheduledActions`, `AddToLoadBalancer`.
	// Note that if you suspend either the `Launch` or `Terminate` process types, it can prevent your autoscaling group from functioning properly.
	SuspendedProcesses pulumi.StringArrayInput `pulumi:"suspendedProcesses"`
	// A list of tag blocks. Tags documented below.
	Tags GroupTagsArrayInput `pulumi:"tags"`
	// A list of tag blocks (maps). Tags documented below.
	TagsCollection pulumi.ArrayInput `pulumi:"tagsCollection"`
	// A list of `alb.TargetGroup` ARNs, for use with Application or Network Load Balancing.
	TargetGroupArns pulumi.StringArrayInput `pulumi:"targetGroupArns"`
	// A list of policies to decide how the instances in the auto scale group should be terminated. The allowed values are `OldestInstance`, `NewestInstance`, `OldestLaunchConfiguration`, `ClosestToNextInstanceHour`, `OldestLaunchTemplate`, `AllocationStrategy`, `Default`.
	TerminationPolicies pulumi.StringArrayInput `pulumi:"terminationPolicies"`
	// A list of subnet IDs to launch resources in.
	VpcZoneIdentifiers pulumi.StringArrayInput `pulumi:"vpcZoneIdentifiers"`
	WaitForCapacityTimeout pulumi.StringInput `pulumi:"waitForCapacityTimeout"`
	// Setting this will cause this provider to wait
	// for exactly this number of healthy instances from this autoscaling group in
	// all attached load balancers on both create and update operations. (Takes
	// precedence over `minElbCapacity` behavior.)
	// (See also Waiting for Capacity below.)
	WaitForElbCapacity pulumi.IntInput `pulumi:"waitForElbCapacity"`
}
type GroupInitialLifecycleHooks struct {
	DefaultResult *string `pulumi:"defaultResult"`
	HeartbeatTimeout *int `pulumi:"heartbeatTimeout"`
	LifecycleTransition string `pulumi:"lifecycleTransition"`
	// The name of the auto scaling group. By default generated by this provider.
	Name string `pulumi:"name"`
	NotificationMetadata *string `pulumi:"notificationMetadata"`
	NotificationTargetArn *string `pulumi:"notificationTargetArn"`
	RoleArn *string `pulumi:"roleArn"`
}
var groupInitialLifecycleHooksType = reflect.TypeOf((*GroupInitialLifecycleHooks)(nil)).Elem()

type GroupInitialLifecycleHooksInput interface {
	pulumi.Input

	ToGroupInitialLifecycleHooksOutput() GroupInitialLifecycleHooksOutput
	ToGroupInitialLifecycleHooksOutputWithContext(ctx context.Context) GroupInitialLifecycleHooksOutput
}

type GroupInitialLifecycleHooksArgs struct {
	DefaultResult pulumi.StringInput `pulumi:"defaultResult"`
	HeartbeatTimeout pulumi.IntInput `pulumi:"heartbeatTimeout"`
	LifecycleTransition pulumi.StringInput `pulumi:"lifecycleTransition"`
	// The name of the auto scaling group. By default generated by this provider.
	Name pulumi.StringInput `pulumi:"name"`
	NotificationMetadata pulumi.StringInput `pulumi:"notificationMetadata"`
	NotificationTargetArn pulumi.StringInput `pulumi:"notificationTargetArn"`
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (GroupInitialLifecycleHooksArgs) ElementType() reflect.Type {
	return groupInitialLifecycleHooksType
}

func (a GroupInitialLifecycleHooksArgs) ToGroupInitialLifecycleHooksOutput() GroupInitialLifecycleHooksOutput {
	return pulumi.ToOutput(a).(GroupInitialLifecycleHooksOutput)
}

func (a GroupInitialLifecycleHooksArgs) ToGroupInitialLifecycleHooksOutputWithContext(ctx context.Context) GroupInitialLifecycleHooksOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupInitialLifecycleHooksOutput)
}

type GroupInitialLifecycleHooksOutput struct { *pulumi.OutputState }

func (o GroupInitialLifecycleHooksOutput) DefaultResult() pulumi.StringOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) string {
		if v.DefaultResult == nil { return *new(string) } else { return *v.DefaultResult }
	}).(pulumi.StringOutput)
}

func (o GroupInitialLifecycleHooksOutput) HeartbeatTimeout() pulumi.IntOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) int {
		if v.HeartbeatTimeout == nil { return *new(int) } else { return *v.HeartbeatTimeout }
	}).(pulumi.IntOutput)
}

func (o GroupInitialLifecycleHooksOutput) LifecycleTransition() pulumi.StringOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) string {
		return v.LifecycleTransition
	}).(pulumi.StringOutput)
}

// The name of the auto scaling group. By default generated by this provider.
func (o GroupInitialLifecycleHooksOutput) Name() pulumi.StringOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) string {
		return v.Name
	}).(pulumi.StringOutput)
}

func (o GroupInitialLifecycleHooksOutput) NotificationMetadata() pulumi.StringOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) string {
		if v.NotificationMetadata == nil { return *new(string) } else { return *v.NotificationMetadata }
	}).(pulumi.StringOutput)
}

func (o GroupInitialLifecycleHooksOutput) NotificationTargetArn() pulumi.StringOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) string {
		if v.NotificationTargetArn == nil { return *new(string) } else { return *v.NotificationTargetArn }
	}).(pulumi.StringOutput)
}

func (o GroupInitialLifecycleHooksOutput) RoleArn() pulumi.StringOutput {
	return o.Apply(func(v GroupInitialLifecycleHooks) string {
		if v.RoleArn == nil { return *new(string) } else { return *v.RoleArn }
	}).(pulumi.StringOutput)
}

func (GroupInitialLifecycleHooksOutput) ElementType() reflect.Type {
	return groupInitialLifecycleHooksType
}

func (o GroupInitialLifecycleHooksOutput) ToGroupInitialLifecycleHooksOutput() GroupInitialLifecycleHooksOutput {
	return o
}

func (o GroupInitialLifecycleHooksOutput) ToGroupInitialLifecycleHooksOutputWithContext(ctx context.Context) GroupInitialLifecycleHooksOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupInitialLifecycleHooksOutput{}) }

var groupInitialLifecycleHooksArrayType = reflect.TypeOf((*[]GroupInitialLifecycleHooks)(nil)).Elem()

type GroupInitialLifecycleHooksArrayInput interface {
	pulumi.Input

	ToGroupInitialLifecycleHooksArrayOutput() GroupInitialLifecycleHooksArrayOutput
	ToGroupInitialLifecycleHooksArrayOutputWithContext(ctx context.Context) GroupInitialLifecycleHooksArrayOutput
}

type GroupInitialLifecycleHooksArrayArgs []GroupInitialLifecycleHooksInput

func (GroupInitialLifecycleHooksArrayArgs) ElementType() reflect.Type {
	return groupInitialLifecycleHooksArrayType
}

func (a GroupInitialLifecycleHooksArrayArgs) ToGroupInitialLifecycleHooksArrayOutput() GroupInitialLifecycleHooksArrayOutput {
	return pulumi.ToOutput(a).(GroupInitialLifecycleHooksArrayOutput)
}

func (a GroupInitialLifecycleHooksArrayArgs) ToGroupInitialLifecycleHooksArrayOutputWithContext(ctx context.Context) GroupInitialLifecycleHooksArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupInitialLifecycleHooksArrayOutput)
}

type GroupInitialLifecycleHooksArrayOutput struct { *pulumi.OutputState }

func (o GroupInitialLifecycleHooksArrayOutput) Index(i pulumi.IntInput) GroupInitialLifecycleHooksOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) GroupInitialLifecycleHooks {
		return vs[0].([]GroupInitialLifecycleHooks)[vs[1].(int)]
	}).(GroupInitialLifecycleHooksOutput)
}

func (GroupInitialLifecycleHooksArrayOutput) ElementType() reflect.Type {
	return groupInitialLifecycleHooksArrayType
}

func (o GroupInitialLifecycleHooksArrayOutput) ToGroupInitialLifecycleHooksArrayOutput() GroupInitialLifecycleHooksArrayOutput {
	return o
}

func (o GroupInitialLifecycleHooksArrayOutput) ToGroupInitialLifecycleHooksArrayOutputWithContext(ctx context.Context) GroupInitialLifecycleHooksArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupInitialLifecycleHooksArrayOutput{}) }

type GroupLaunchTemplate struct {
	// The autoscaling group id.
	Id *string `pulumi:"id"`
	// The name of the auto scaling group. By default generated by this provider.
	Name *string `pulumi:"name"`
	// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
	Version *string `pulumi:"version"`
}
var groupLaunchTemplateType = reflect.TypeOf((*GroupLaunchTemplate)(nil)).Elem()

type GroupLaunchTemplateInput interface {
	pulumi.Input

	ToGroupLaunchTemplateOutput() GroupLaunchTemplateOutput
	ToGroupLaunchTemplateOutputWithContext(ctx context.Context) GroupLaunchTemplateOutput
}

type GroupLaunchTemplateArgs struct {
	// The autoscaling group id.
	Id pulumi.StringInput `pulumi:"id"`
	// The name of the auto scaling group. By default generated by this provider.
	Name pulumi.StringInput `pulumi:"name"`
	// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
	Version pulumi.StringInput `pulumi:"version"`
}

func (GroupLaunchTemplateArgs) ElementType() reflect.Type {
	return groupLaunchTemplateType
}

func (a GroupLaunchTemplateArgs) ToGroupLaunchTemplateOutput() GroupLaunchTemplateOutput {
	return pulumi.ToOutput(a).(GroupLaunchTemplateOutput)
}

func (a GroupLaunchTemplateArgs) ToGroupLaunchTemplateOutputWithContext(ctx context.Context) GroupLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupLaunchTemplateOutput)
}

type GroupLaunchTemplateOutput struct { *pulumi.OutputState }

// The autoscaling group id.
func (o GroupLaunchTemplateOutput) Id() pulumi.StringOutput {
	return o.Apply(func(v GroupLaunchTemplate) string {
		if v.Id == nil { return *new(string) } else { return *v.Id }
	}).(pulumi.StringOutput)
}

// The name of the auto scaling group. By default generated by this provider.
func (o GroupLaunchTemplateOutput) Name() pulumi.StringOutput {
	return o.Apply(func(v GroupLaunchTemplate) string {
		if v.Name == nil { return *new(string) } else { return *v.Name }
	}).(pulumi.StringOutput)
}

// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
func (o GroupLaunchTemplateOutput) Version() pulumi.StringOutput {
	return o.Apply(func(v GroupLaunchTemplate) string {
		if v.Version == nil { return *new(string) } else { return *v.Version }
	}).(pulumi.StringOutput)
}

func (GroupLaunchTemplateOutput) ElementType() reflect.Type {
	return groupLaunchTemplateType
}

func (o GroupLaunchTemplateOutput) ToGroupLaunchTemplateOutput() GroupLaunchTemplateOutput {
	return o
}

func (o GroupLaunchTemplateOutput) ToGroupLaunchTemplateOutputWithContext(ctx context.Context) GroupLaunchTemplateOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupLaunchTemplateOutput{}) }

type GroupMixedInstancesPolicy struct {
	// Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
	InstancesDistribution *GroupMixedInstancesPolicyInstancesDistribution `pulumi:"instancesDistribution"`
	// Nested argument containing launch template settings along with the overrides to specify multiple instance types. Defined below.
	LaunchTemplate GroupMixedInstancesPolicyLaunchTemplate `pulumi:"launchTemplate"`
}
var groupMixedInstancesPolicyType = reflect.TypeOf((*GroupMixedInstancesPolicy)(nil)).Elem()

type GroupMixedInstancesPolicyInput interface {
	pulumi.Input

	ToGroupMixedInstancesPolicyOutput() GroupMixedInstancesPolicyOutput
	ToGroupMixedInstancesPolicyOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyOutput
}

type GroupMixedInstancesPolicyArgs struct {
	// Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
	InstancesDistribution GroupMixedInstancesPolicyInstancesDistributionInput `pulumi:"instancesDistribution"`
	// Nested argument containing launch template settings along with the overrides to specify multiple instance types. Defined below.
	LaunchTemplate GroupMixedInstancesPolicyLaunchTemplateInput `pulumi:"launchTemplate"`
}

func (GroupMixedInstancesPolicyArgs) ElementType() reflect.Type {
	return groupMixedInstancesPolicyType
}

func (a GroupMixedInstancesPolicyArgs) ToGroupMixedInstancesPolicyOutput() GroupMixedInstancesPolicyOutput {
	return pulumi.ToOutput(a).(GroupMixedInstancesPolicyOutput)
}

func (a GroupMixedInstancesPolicyArgs) ToGroupMixedInstancesPolicyOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupMixedInstancesPolicyOutput)
}

type GroupMixedInstancesPolicyOutput struct { *pulumi.OutputState }

// Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
func (o GroupMixedInstancesPolicyOutput) InstancesDistribution() GroupMixedInstancesPolicyInstancesDistributionOutput {
	return o.Apply(func(v GroupMixedInstancesPolicy) GroupMixedInstancesPolicyInstancesDistribution {
		if v.InstancesDistribution == nil { return *new(GroupMixedInstancesPolicyInstancesDistribution) } else { return *v.InstancesDistribution }
	}).(GroupMixedInstancesPolicyInstancesDistributionOutput)
}

// Nested argument containing launch template settings along with the overrides to specify multiple instance types. Defined below.
func (o GroupMixedInstancesPolicyOutput) LaunchTemplate() GroupMixedInstancesPolicyLaunchTemplateOutput {
	return o.Apply(func(v GroupMixedInstancesPolicy) GroupMixedInstancesPolicyLaunchTemplate {
		return v.LaunchTemplate
	}).(GroupMixedInstancesPolicyLaunchTemplateOutput)
}

func (GroupMixedInstancesPolicyOutput) ElementType() reflect.Type {
	return groupMixedInstancesPolicyType
}

func (o GroupMixedInstancesPolicyOutput) ToGroupMixedInstancesPolicyOutput() GroupMixedInstancesPolicyOutput {
	return o
}

func (o GroupMixedInstancesPolicyOutput) ToGroupMixedInstancesPolicyOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupMixedInstancesPolicyOutput{}) }

type GroupMixedInstancesPolicyInstancesDistribution struct {
	// Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
	OnDemandAllocationStrategy *string `pulumi:"onDemandAllocationStrategy"`
	// Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
	OnDemandBaseCapacity *int `pulumi:"onDemandBaseCapacity"`
	// Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
	OnDemandPercentageAboveBaseCapacity *int `pulumi:"onDemandPercentageAboveBaseCapacity"`
	// How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
	SpotAllocationStrategy *string `pulumi:"spotAllocationStrategy"`
	// Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
	SpotInstancePools *int `pulumi:"spotInstancePools"`
	// Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
	SpotMaxPrice *string `pulumi:"spotMaxPrice"`
}
var groupMixedInstancesPolicyInstancesDistributionType = reflect.TypeOf((*GroupMixedInstancesPolicyInstancesDistribution)(nil)).Elem()

type GroupMixedInstancesPolicyInstancesDistributionInput interface {
	pulumi.Input

	ToGroupMixedInstancesPolicyInstancesDistributionOutput() GroupMixedInstancesPolicyInstancesDistributionOutput
	ToGroupMixedInstancesPolicyInstancesDistributionOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyInstancesDistributionOutput
}

type GroupMixedInstancesPolicyInstancesDistributionArgs struct {
	// Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
	OnDemandAllocationStrategy pulumi.StringInput `pulumi:"onDemandAllocationStrategy"`
	// Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
	OnDemandBaseCapacity pulumi.IntInput `pulumi:"onDemandBaseCapacity"`
	// Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
	OnDemandPercentageAboveBaseCapacity pulumi.IntInput `pulumi:"onDemandPercentageAboveBaseCapacity"`
	// How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
	SpotAllocationStrategy pulumi.StringInput `pulumi:"spotAllocationStrategy"`
	// Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
	SpotInstancePools pulumi.IntInput `pulumi:"spotInstancePools"`
	// Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
	SpotMaxPrice pulumi.StringInput `pulumi:"spotMaxPrice"`
}

func (GroupMixedInstancesPolicyInstancesDistributionArgs) ElementType() reflect.Type {
	return groupMixedInstancesPolicyInstancesDistributionType
}

func (a GroupMixedInstancesPolicyInstancesDistributionArgs) ToGroupMixedInstancesPolicyInstancesDistributionOutput() GroupMixedInstancesPolicyInstancesDistributionOutput {
	return pulumi.ToOutput(a).(GroupMixedInstancesPolicyInstancesDistributionOutput)
}

func (a GroupMixedInstancesPolicyInstancesDistributionArgs) ToGroupMixedInstancesPolicyInstancesDistributionOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyInstancesDistributionOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupMixedInstancesPolicyInstancesDistributionOutput)
}

type GroupMixedInstancesPolicyInstancesDistributionOutput struct { *pulumi.OutputState }

// Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
func (o GroupMixedInstancesPolicyInstancesDistributionOutput) OnDemandAllocationStrategy() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyInstancesDistribution) string {
		if v.OnDemandAllocationStrategy == nil { return *new(string) } else { return *v.OnDemandAllocationStrategy }
	}).(pulumi.StringOutput)
}

// Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
func (o GroupMixedInstancesPolicyInstancesDistributionOutput) OnDemandBaseCapacity() pulumi.IntOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyInstancesDistribution) int {
		if v.OnDemandBaseCapacity == nil { return *new(int) } else { return *v.OnDemandBaseCapacity }
	}).(pulumi.IntOutput)
}

// Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `100`.
func (o GroupMixedInstancesPolicyInstancesDistributionOutput) OnDemandPercentageAboveBaseCapacity() pulumi.IntOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyInstancesDistribution) int {
		if v.OnDemandPercentageAboveBaseCapacity == nil { return *new(int) } else { return *v.OnDemandPercentageAboveBaseCapacity }
	}).(pulumi.IntOutput)
}

// How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
func (o GroupMixedInstancesPolicyInstancesDistributionOutput) SpotAllocationStrategy() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyInstancesDistribution) string {
		if v.SpotAllocationStrategy == nil { return *new(string) } else { return *v.SpotAllocationStrategy }
	}).(pulumi.StringOutput)
}

// Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
func (o GroupMixedInstancesPolicyInstancesDistributionOutput) SpotInstancePools() pulumi.IntOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyInstancesDistribution) int {
		if v.SpotInstancePools == nil { return *new(int) } else { return *v.SpotInstancePools }
	}).(pulumi.IntOutput)
}

// Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
func (o GroupMixedInstancesPolicyInstancesDistributionOutput) SpotMaxPrice() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyInstancesDistribution) string {
		if v.SpotMaxPrice == nil { return *new(string) } else { return *v.SpotMaxPrice }
	}).(pulumi.StringOutput)
}

func (GroupMixedInstancesPolicyInstancesDistributionOutput) ElementType() reflect.Type {
	return groupMixedInstancesPolicyInstancesDistributionType
}

func (o GroupMixedInstancesPolicyInstancesDistributionOutput) ToGroupMixedInstancesPolicyInstancesDistributionOutput() GroupMixedInstancesPolicyInstancesDistributionOutput {
	return o
}

func (o GroupMixedInstancesPolicyInstancesDistributionOutput) ToGroupMixedInstancesPolicyInstancesDistributionOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyInstancesDistributionOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupMixedInstancesPolicyInstancesDistributionOutput{}) }

type GroupMixedInstancesPolicyLaunchTemplate struct {
	// Nested argument defines the Launch Template. Defined below.
	LaunchTemplateSpecification GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification `pulumi:"launchTemplateSpecification"`
	// List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
	Overrides *[]GroupMixedInstancesPolicyLaunchTemplateOverrides `pulumi:"overrides"`
}
var groupMixedInstancesPolicyLaunchTemplateType = reflect.TypeOf((*GroupMixedInstancesPolicyLaunchTemplate)(nil)).Elem()

type GroupMixedInstancesPolicyLaunchTemplateInput interface {
	pulumi.Input

	ToGroupMixedInstancesPolicyLaunchTemplateOutput() GroupMixedInstancesPolicyLaunchTemplateOutput
	ToGroupMixedInstancesPolicyLaunchTemplateOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOutput
}

type GroupMixedInstancesPolicyLaunchTemplateArgs struct {
	// Nested argument defines the Launch Template. Defined below.
	LaunchTemplateSpecification GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationInput `pulumi:"launchTemplateSpecification"`
	// List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
	Overrides GroupMixedInstancesPolicyLaunchTemplateOverridesArrayInput `pulumi:"overrides"`
}

func (GroupMixedInstancesPolicyLaunchTemplateArgs) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateType
}

func (a GroupMixedInstancesPolicyLaunchTemplateArgs) ToGroupMixedInstancesPolicyLaunchTemplateOutput() GroupMixedInstancesPolicyLaunchTemplateOutput {
	return pulumi.ToOutput(a).(GroupMixedInstancesPolicyLaunchTemplateOutput)
}

func (a GroupMixedInstancesPolicyLaunchTemplateArgs) ToGroupMixedInstancesPolicyLaunchTemplateOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupMixedInstancesPolicyLaunchTemplateOutput)
}

type GroupMixedInstancesPolicyLaunchTemplateOutput struct { *pulumi.OutputState }

// Nested argument defines the Launch Template. Defined below.
func (o GroupMixedInstancesPolicyLaunchTemplateOutput) LaunchTemplateSpecification() GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyLaunchTemplate) GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
		return v.LaunchTemplateSpecification
	}).(GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput)
}

// List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
func (o GroupMixedInstancesPolicyLaunchTemplateOutput) Overrides() GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyLaunchTemplate) []GroupMixedInstancesPolicyLaunchTemplateOverrides {
		if v.Overrides == nil { return *new([]GroupMixedInstancesPolicyLaunchTemplateOverrides) } else { return *v.Overrides }
	}).(GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput)
}

func (GroupMixedInstancesPolicyLaunchTemplateOutput) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateType
}

func (o GroupMixedInstancesPolicyLaunchTemplateOutput) ToGroupMixedInstancesPolicyLaunchTemplateOutput() GroupMixedInstancesPolicyLaunchTemplateOutput {
	return o
}

func (o GroupMixedInstancesPolicyLaunchTemplateOutput) ToGroupMixedInstancesPolicyLaunchTemplateOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupMixedInstancesPolicyLaunchTemplateOutput{}) }

type GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification struct {
	// The ID of the launch template. Conflicts with `launchTemplateName`.
	LaunchTemplateId *string `pulumi:"launchTemplateId"`
	// The name of the launch template. Conflicts with `launchTemplateId`.
	LaunchTemplateName *string `pulumi:"launchTemplateName"`
	// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
	Version *string `pulumi:"version"`
}
var groupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationType = reflect.TypeOf((*GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(nil)).Elem()

type GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationInput interface {
	pulumi.Input

	ToGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput() GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput
	ToGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput
}

type GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs struct {
	// The ID of the launch template. Conflicts with `launchTemplateName`.
	LaunchTemplateId pulumi.StringInput `pulumi:"launchTemplateId"`
	// The name of the launch template. Conflicts with `launchTemplateId`.
	LaunchTemplateName pulumi.StringInput `pulumi:"launchTemplateName"`
	// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
	Version pulumi.StringInput `pulumi:"version"`
}

func (GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationType
}

func (a GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs) ToGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput() GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput {
	return pulumi.ToOutput(a).(GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput)
}

func (a GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationArgs) ToGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput)
}

type GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput struct { *pulumi.OutputState }

// The ID of the launch template. Conflicts with `launchTemplateName`.
func (o GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput) LaunchTemplateId() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification) string {
		if v.LaunchTemplateId == nil { return *new(string) } else { return *v.LaunchTemplateId }
	}).(pulumi.StringOutput)
}

// The name of the launch template. Conflicts with `launchTemplateId`.
func (o GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput) LaunchTemplateName() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification) string {
		if v.LaunchTemplateName == nil { return *new(string) } else { return *v.LaunchTemplateName }
	}).(pulumi.StringOutput)
}

// Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
func (o GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput) Version() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification) string {
		if v.Version == nil { return *new(string) } else { return *v.Version }
	}).(pulumi.StringOutput)
}

func (GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationType
}

func (o GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput) ToGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput() GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput {
	return o
}

func (o GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput) ToGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationOutput{}) }

type GroupMixedInstancesPolicyLaunchTemplateOverrides struct {
	// Override the instance type in the Launch Template.
	InstanceType *string `pulumi:"instanceType"`
}
var groupMixedInstancesPolicyLaunchTemplateOverridesType = reflect.TypeOf((*GroupMixedInstancesPolicyLaunchTemplateOverrides)(nil)).Elem()

type GroupMixedInstancesPolicyLaunchTemplateOverridesInput interface {
	pulumi.Input

	ToGroupMixedInstancesPolicyLaunchTemplateOverridesOutput() GroupMixedInstancesPolicyLaunchTemplateOverridesOutput
	ToGroupMixedInstancesPolicyLaunchTemplateOverridesOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOverridesOutput
}

type GroupMixedInstancesPolicyLaunchTemplateOverridesArgs struct {
	// Override the instance type in the Launch Template.
	InstanceType pulumi.StringInput `pulumi:"instanceType"`
}

func (GroupMixedInstancesPolicyLaunchTemplateOverridesArgs) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateOverridesType
}

func (a GroupMixedInstancesPolicyLaunchTemplateOverridesArgs) ToGroupMixedInstancesPolicyLaunchTemplateOverridesOutput() GroupMixedInstancesPolicyLaunchTemplateOverridesOutput {
	return pulumi.ToOutput(a).(GroupMixedInstancesPolicyLaunchTemplateOverridesOutput)
}

func (a GroupMixedInstancesPolicyLaunchTemplateOverridesArgs) ToGroupMixedInstancesPolicyLaunchTemplateOverridesOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupMixedInstancesPolicyLaunchTemplateOverridesOutput)
}

type GroupMixedInstancesPolicyLaunchTemplateOverridesOutput struct { *pulumi.OutputState }

// Override the instance type in the Launch Template.
func (o GroupMixedInstancesPolicyLaunchTemplateOverridesOutput) InstanceType() pulumi.StringOutput {
	return o.Apply(func(v GroupMixedInstancesPolicyLaunchTemplateOverrides) string {
		if v.InstanceType == nil { return *new(string) } else { return *v.InstanceType }
	}).(pulumi.StringOutput)
}

func (GroupMixedInstancesPolicyLaunchTemplateOverridesOutput) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateOverridesType
}

func (o GroupMixedInstancesPolicyLaunchTemplateOverridesOutput) ToGroupMixedInstancesPolicyLaunchTemplateOverridesOutput() GroupMixedInstancesPolicyLaunchTemplateOverridesOutput {
	return o
}

func (o GroupMixedInstancesPolicyLaunchTemplateOverridesOutput) ToGroupMixedInstancesPolicyLaunchTemplateOverridesOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOverridesOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupMixedInstancesPolicyLaunchTemplateOverridesOutput{}) }

var groupMixedInstancesPolicyLaunchTemplateOverridesArrayType = reflect.TypeOf((*[]GroupMixedInstancesPolicyLaunchTemplateOverrides)(nil)).Elem()

type GroupMixedInstancesPolicyLaunchTemplateOverridesArrayInput interface {
	pulumi.Input

	ToGroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput() GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput
	ToGroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput
}

type GroupMixedInstancesPolicyLaunchTemplateOverridesArrayArgs []GroupMixedInstancesPolicyLaunchTemplateOverridesInput

func (GroupMixedInstancesPolicyLaunchTemplateOverridesArrayArgs) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateOverridesArrayType
}

func (a GroupMixedInstancesPolicyLaunchTemplateOverridesArrayArgs) ToGroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput() GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput {
	return pulumi.ToOutput(a).(GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput)
}

func (a GroupMixedInstancesPolicyLaunchTemplateOverridesArrayArgs) ToGroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput)
}

type GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput struct { *pulumi.OutputState }

func (o GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput) Index(i pulumi.IntInput) GroupMixedInstancesPolicyLaunchTemplateOverridesOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) GroupMixedInstancesPolicyLaunchTemplateOverrides {
		return vs[0].([]GroupMixedInstancesPolicyLaunchTemplateOverrides)[vs[1].(int)]
	}).(GroupMixedInstancesPolicyLaunchTemplateOverridesOutput)
}

func (GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput) ElementType() reflect.Type {
	return groupMixedInstancesPolicyLaunchTemplateOverridesArrayType
}

func (o GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput) ToGroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput() GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput {
	return o
}

func (o GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput) ToGroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutputWithContext(ctx context.Context) GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupMixedInstancesPolicyLaunchTemplateOverridesArrayOutput{}) }

type GroupTags struct {
	// Key
	Key string `pulumi:"key"`
	// Enables propagation of the tag to
	// Amazon EC2 instances launched via this ASG
	PropagateAtLaunch bool `pulumi:"propagateAtLaunch"`
	// Value
	Value string `pulumi:"value"`
}
var groupTagsType = reflect.TypeOf((*GroupTags)(nil)).Elem()

type GroupTagsInput interface {
	pulumi.Input

	ToGroupTagsOutput() GroupTagsOutput
	ToGroupTagsOutputWithContext(ctx context.Context) GroupTagsOutput
}

type GroupTagsArgs struct {
	// Key
	Key pulumi.StringInput `pulumi:"key"`
	// Enables propagation of the tag to
	// Amazon EC2 instances launched via this ASG
	PropagateAtLaunch pulumi.BoolInput `pulumi:"propagateAtLaunch"`
	// Value
	Value pulumi.StringInput `pulumi:"value"`
}

func (GroupTagsArgs) ElementType() reflect.Type {
	return groupTagsType
}

func (a GroupTagsArgs) ToGroupTagsOutput() GroupTagsOutput {
	return pulumi.ToOutput(a).(GroupTagsOutput)
}

func (a GroupTagsArgs) ToGroupTagsOutputWithContext(ctx context.Context) GroupTagsOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupTagsOutput)
}

type GroupTagsOutput struct { *pulumi.OutputState }

// Key
func (o GroupTagsOutput) Key() pulumi.StringOutput {
	return o.Apply(func(v GroupTags) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Enables propagation of the tag to
// Amazon EC2 instances launched via this ASG
func (o GroupTagsOutput) PropagateAtLaunch() pulumi.BoolOutput {
	return o.Apply(func(v GroupTags) bool {
		return v.PropagateAtLaunch
	}).(pulumi.BoolOutput)
}

// Value
func (o GroupTagsOutput) Value() pulumi.StringOutput {
	return o.Apply(func(v GroupTags) string {
		return v.Value
	}).(pulumi.StringOutput)
}

func (GroupTagsOutput) ElementType() reflect.Type {
	return groupTagsType
}

func (o GroupTagsOutput) ToGroupTagsOutput() GroupTagsOutput {
	return o
}

func (o GroupTagsOutput) ToGroupTagsOutputWithContext(ctx context.Context) GroupTagsOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupTagsOutput{}) }

var groupTagsArrayType = reflect.TypeOf((*[]GroupTags)(nil)).Elem()

type GroupTagsArrayInput interface {
	pulumi.Input

	ToGroupTagsArrayOutput() GroupTagsArrayOutput
	ToGroupTagsArrayOutputWithContext(ctx context.Context) GroupTagsArrayOutput
}

type GroupTagsArrayArgs []GroupTagsInput

func (GroupTagsArrayArgs) ElementType() reflect.Type {
	return groupTagsArrayType
}

func (a GroupTagsArrayArgs) ToGroupTagsArrayOutput() GroupTagsArrayOutput {
	return pulumi.ToOutput(a).(GroupTagsArrayOutput)
}

func (a GroupTagsArrayArgs) ToGroupTagsArrayOutputWithContext(ctx context.Context) GroupTagsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(GroupTagsArrayOutput)
}

type GroupTagsArrayOutput struct { *pulumi.OutputState }

func (o GroupTagsArrayOutput) Index(i pulumi.IntInput) GroupTagsOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) GroupTags {
		return vs[0].([]GroupTags)[vs[1].(int)]
	}).(GroupTagsOutput)
}

func (GroupTagsArrayOutput) ElementType() reflect.Type {
	return groupTagsArrayType
}

func (o GroupTagsArrayOutput) ToGroupTagsArrayOutput() GroupTagsArrayOutput {
	return o
}

func (o GroupTagsArrayOutput) ToGroupTagsArrayOutputWithContext(ctx context.Context) GroupTagsArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(GroupTagsArrayOutput{}) }

