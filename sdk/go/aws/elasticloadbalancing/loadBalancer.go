// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package elasticloadbalancing

import (
	"context"
	"reflect"
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides an Elastic Load Balancer resource, also known as a "Classic
// Load Balancer" after the release of
// [Application/Network Load Balancers](https://www.terraform.io/docs/providers/aws/r/lb.html).
// 
// > **NOTE on ELB Instances and ELB Attachments:** This provider currently
// provides both a standalone ELB Attachment resource
// (describing an instance attached to an ELB), and an ELB resource with
// `instances` defined in-line. At this time you cannot use an ELB with in-line
// instances in conjunction with a ELB Attachment resources. Doing so will cause a
// conflict and will overwrite attachments.
// 
// ## Note on ECDSA Key Algorithm
// 
// If the ARN of the `sslCertificateId` that is pointed to references a
// certificate that was signed by an ECDSA key, note that ELB only supports the
// P256 and P384 curves.  Using a certificate signed by a key using a different
// curve could produce the error `ERR_SSL_VERSION_OR_CIPHER_MISMATCH` in your
// browser.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-aws/blob/master/website/docs/r/elb_legacy.html.markdown.
type LoadBalancer struct {
	pulumi.CustomResourceState

	// An Access Logs block. Access Logs documented below.
	AccessLogs LoadBalancerAccessLogsOutput `pulumi:"accessLogs"`

	// The ARN of the ELB
	Arn pulumi.StringOutput `pulumi:"arn"`

	// The AZ's to serve traffic in.
	AvailabilityZones pulumi.StringArrayOutput `pulumi:"availabilityZones"`

	// Boolean to enable connection draining. Default: `false`
	ConnectionDraining pulumi.BoolOutput `pulumi:"connectionDraining"`

	// The time in seconds to allow for connections to drain. Default: `300`
	ConnectionDrainingTimeout pulumi.IntOutput `pulumi:"connectionDrainingTimeout"`

	// Enable cross-zone load balancing. Default: `true`
	CrossZoneLoadBalancing pulumi.BoolOutput `pulumi:"crossZoneLoadBalancing"`

	// The DNS name of the ELB
	DnsName pulumi.StringOutput `pulumi:"dnsName"`

	// A healthCheck block. Health Check documented below.
	HealthCheck LoadBalancerHealthCheckOutput `pulumi:"healthCheck"`

	// The time in seconds that the connection is allowed to be idle. Default: `60`
	IdleTimeout pulumi.IntOutput `pulumi:"idleTimeout"`

	// A list of instance ids to place in the ELB pool.
	Instances pulumi.StringArrayOutput `pulumi:"instances"`

	// If true, ELB will be an internal ELB.
	Internal pulumi.BoolOutput `pulumi:"internal"`

	// A list of listener blocks. Listeners documented below.
	Listeners LoadBalancerListenersArrayOutput `pulumi:"listeners"`

	// The name of the ELB. By default generated by this provider.
	Name pulumi.StringOutput `pulumi:"name"`

	// Creates a unique name beginning with the specified
	// prefix. Conflicts with `name`.
	NamePrefix pulumi.StringOutput `pulumi:"namePrefix"`

	// A list of security group IDs to assign to the ELB.
	// Only valid if creating an ELB within a VPC
	SecurityGroups pulumi.StringArrayOutput `pulumi:"securityGroups"`

	// The name of the security group that you can use as
	// part of your inbound rules for your load balancer's back-end application
	// instances. Use this for Classic or Default VPC only.
	SourceSecurityGroup pulumi.StringOutput `pulumi:"sourceSecurityGroup"`

	// The ID of the security group that you can use as
	// part of your inbound rules for your load balancer's back-end application
	// instances. Only available on ELBs launched in a VPC.
	SourceSecurityGroupId pulumi.StringOutput `pulumi:"sourceSecurityGroupId"`

	// A list of subnet IDs to attach to the ELB.
	Subnets pulumi.StringArrayOutput `pulumi:"subnets"`

	// A mapping of tags to assign to the resource.
	Tags pulumi.MapOutput `pulumi:"tags"`

	// The canonical hosted zone ID of the ELB (to be used in a Route 53 Alias record)
	ZoneId pulumi.StringOutput `pulumi:"zoneId"`
}

// NewLoadBalancer registers a new resource with the given unique name, arguments, and options.
func NewLoadBalancer(ctx *pulumi.Context,
	name string, args *LoadBalancerArgs, opts ...pulumi.ResourceOption) (*LoadBalancer, error) {
	if args == nil || args.Listeners == nil {
		return nil, errors.New("missing required argument 'Listeners'")
	}
	inputs := map[string]pulumi.Input{}
	if args != nil {
		if i := args.AccessLogs; i != nil { inputs["accessLogs"] = i.ToLoadBalancerAccessLogsOutput() }
		if i := args.AvailabilityZones; i != nil { inputs["availabilityZones"] = i.ToStringArrayOutput() }
		if i := args.ConnectionDraining; i != nil { inputs["connectionDraining"] = i.ToBoolOutput() }
		if i := args.ConnectionDrainingTimeout; i != nil { inputs["connectionDrainingTimeout"] = i.ToIntOutput() }
		if i := args.CrossZoneLoadBalancing; i != nil { inputs["crossZoneLoadBalancing"] = i.ToBoolOutput() }
		if i := args.HealthCheck; i != nil { inputs["healthCheck"] = i.ToLoadBalancerHealthCheckOutput() }
		if i := args.IdleTimeout; i != nil { inputs["idleTimeout"] = i.ToIntOutput() }
		if i := args.Instances; i != nil { inputs["instances"] = i.ToStringArrayOutput() }
		if i := args.Internal; i != nil { inputs["internal"] = i.ToBoolOutput() }
		if i := args.Listeners; i != nil { inputs["listeners"] = i.ToLoadBalancerListenersArrayOutput() }
		if i := args.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := args.NamePrefix; i != nil { inputs["namePrefix"] = i.ToStringOutput() }
		if i := args.SecurityGroups; i != nil { inputs["securityGroups"] = i.ToStringArrayOutput() }
		if i := args.SourceSecurityGroup; i != nil { inputs["sourceSecurityGroup"] = i.ToStringOutput() }
		if i := args.Subnets; i != nil { inputs["subnets"] = i.ToStringArrayOutput() }
		if i := args.Tags; i != nil { inputs["tags"] = i.ToMapOutput() }
	}
	var resource LoadBalancer
	err := ctx.RegisterResource("aws:elasticloadbalancing/loadBalancer:LoadBalancer", name, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLoadBalancer gets an existing LoadBalancer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLoadBalancer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LoadBalancerState, opts ...pulumi.ResourceOption) (*LoadBalancer, error) {
	inputs := map[string]pulumi.Input{}
	if state != nil {
		if i := state.AccessLogs; i != nil { inputs["accessLogs"] = i.ToLoadBalancerAccessLogsOutput() }
		if i := state.Arn; i != nil { inputs["arn"] = i.ToStringOutput() }
		if i := state.AvailabilityZones; i != nil { inputs["availabilityZones"] = i.ToStringArrayOutput() }
		if i := state.ConnectionDraining; i != nil { inputs["connectionDraining"] = i.ToBoolOutput() }
		if i := state.ConnectionDrainingTimeout; i != nil { inputs["connectionDrainingTimeout"] = i.ToIntOutput() }
		if i := state.CrossZoneLoadBalancing; i != nil { inputs["crossZoneLoadBalancing"] = i.ToBoolOutput() }
		if i := state.DnsName; i != nil { inputs["dnsName"] = i.ToStringOutput() }
		if i := state.HealthCheck; i != nil { inputs["healthCheck"] = i.ToLoadBalancerHealthCheckOutput() }
		if i := state.IdleTimeout; i != nil { inputs["idleTimeout"] = i.ToIntOutput() }
		if i := state.Instances; i != nil { inputs["instances"] = i.ToStringArrayOutput() }
		if i := state.Internal; i != nil { inputs["internal"] = i.ToBoolOutput() }
		if i := state.Listeners; i != nil { inputs["listeners"] = i.ToLoadBalancerListenersArrayOutput() }
		if i := state.Name; i != nil { inputs["name"] = i.ToStringOutput() }
		if i := state.NamePrefix; i != nil { inputs["namePrefix"] = i.ToStringOutput() }
		if i := state.SecurityGroups; i != nil { inputs["securityGroups"] = i.ToStringArrayOutput() }
		if i := state.SourceSecurityGroup; i != nil { inputs["sourceSecurityGroup"] = i.ToStringOutput() }
		if i := state.SourceSecurityGroupId; i != nil { inputs["sourceSecurityGroupId"] = i.ToStringOutput() }
		if i := state.Subnets; i != nil { inputs["subnets"] = i.ToStringArrayOutput() }
		if i := state.Tags; i != nil { inputs["tags"] = i.ToMapOutput() }
		if i := state.ZoneId; i != nil { inputs["zoneId"] = i.ToStringOutput() }
	}
	var resource LoadBalancer
	err := ctx.ReadResource("aws:elasticloadbalancing/loadBalancer:LoadBalancer", name, id, inputs, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LoadBalancer resources.
type LoadBalancerState struct {
	// An Access Logs block. Access Logs documented below.
	AccessLogs LoadBalancerAccessLogsInput `pulumi:"accessLogs"`
	// The ARN of the ELB
	Arn pulumi.StringInput `pulumi:"arn"`
	// The AZ's to serve traffic in.
	AvailabilityZones pulumi.StringArrayInput `pulumi:"availabilityZones"`
	// Boolean to enable connection draining. Default: `false`
	ConnectionDraining pulumi.BoolInput `pulumi:"connectionDraining"`
	// The time in seconds to allow for connections to drain. Default: `300`
	ConnectionDrainingTimeout pulumi.IntInput `pulumi:"connectionDrainingTimeout"`
	// Enable cross-zone load balancing. Default: `true`
	CrossZoneLoadBalancing pulumi.BoolInput `pulumi:"crossZoneLoadBalancing"`
	// The DNS name of the ELB
	DnsName pulumi.StringInput `pulumi:"dnsName"`
	// A healthCheck block. Health Check documented below.
	HealthCheck LoadBalancerHealthCheckInput `pulumi:"healthCheck"`
	// The time in seconds that the connection is allowed to be idle. Default: `60`
	IdleTimeout pulumi.IntInput `pulumi:"idleTimeout"`
	// A list of instance ids to place in the ELB pool.
	Instances pulumi.StringArrayInput `pulumi:"instances"`
	// If true, ELB will be an internal ELB.
	Internal pulumi.BoolInput `pulumi:"internal"`
	// A list of listener blocks. Listeners documented below.
	Listeners LoadBalancerListenersArrayInput `pulumi:"listeners"`
	// The name of the ELB. By default generated by this provider.
	Name pulumi.StringInput `pulumi:"name"`
	// Creates a unique name beginning with the specified
	// prefix. Conflicts with `name`.
	NamePrefix pulumi.StringInput `pulumi:"namePrefix"`
	// A list of security group IDs to assign to the ELB.
	// Only valid if creating an ELB within a VPC
	SecurityGroups pulumi.StringArrayInput `pulumi:"securityGroups"`
	// The name of the security group that you can use as
	// part of your inbound rules for your load balancer's back-end application
	// instances. Use this for Classic or Default VPC only.
	SourceSecurityGroup pulumi.StringInput `pulumi:"sourceSecurityGroup"`
	// The ID of the security group that you can use as
	// part of your inbound rules for your load balancer's back-end application
	// instances. Only available on ELBs launched in a VPC.
	SourceSecurityGroupId pulumi.StringInput `pulumi:"sourceSecurityGroupId"`
	// A list of subnet IDs to attach to the ELB.
	Subnets pulumi.StringArrayInput `pulumi:"subnets"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.MapInput `pulumi:"tags"`
	// The canonical hosted zone ID of the ELB (to be used in a Route 53 Alias record)
	ZoneId pulumi.StringInput `pulumi:"zoneId"`
}

// The set of arguments for constructing a LoadBalancer resource.
type LoadBalancerArgs struct {
	// An Access Logs block. Access Logs documented below.
	AccessLogs LoadBalancerAccessLogsInput `pulumi:"accessLogs"`
	// The AZ's to serve traffic in.
	AvailabilityZones pulumi.StringArrayInput `pulumi:"availabilityZones"`
	// Boolean to enable connection draining. Default: `false`
	ConnectionDraining pulumi.BoolInput `pulumi:"connectionDraining"`
	// The time in seconds to allow for connections to drain. Default: `300`
	ConnectionDrainingTimeout pulumi.IntInput `pulumi:"connectionDrainingTimeout"`
	// Enable cross-zone load balancing. Default: `true`
	CrossZoneLoadBalancing pulumi.BoolInput `pulumi:"crossZoneLoadBalancing"`
	// A healthCheck block. Health Check documented below.
	HealthCheck LoadBalancerHealthCheckInput `pulumi:"healthCheck"`
	// The time in seconds that the connection is allowed to be idle. Default: `60`
	IdleTimeout pulumi.IntInput `pulumi:"idleTimeout"`
	// A list of instance ids to place in the ELB pool.
	Instances pulumi.StringArrayInput `pulumi:"instances"`
	// If true, ELB will be an internal ELB.
	Internal pulumi.BoolInput `pulumi:"internal"`
	// A list of listener blocks. Listeners documented below.
	Listeners LoadBalancerListenersArrayInput `pulumi:"listeners"`
	// The name of the ELB. By default generated by this provider.
	Name pulumi.StringInput `pulumi:"name"`
	// Creates a unique name beginning with the specified
	// prefix. Conflicts with `name`.
	NamePrefix pulumi.StringInput `pulumi:"namePrefix"`
	// A list of security group IDs to assign to the ELB.
	// Only valid if creating an ELB within a VPC
	SecurityGroups pulumi.StringArrayInput `pulumi:"securityGroups"`
	// The name of the security group that you can use as
	// part of your inbound rules for your load balancer's back-end application
	// instances. Use this for Classic or Default VPC only.
	SourceSecurityGroup pulumi.StringInput `pulumi:"sourceSecurityGroup"`
	// A list of subnet IDs to attach to the ELB.
	Subnets pulumi.StringArrayInput `pulumi:"subnets"`
	// A mapping of tags to assign to the resource.
	Tags pulumi.MapInput `pulumi:"tags"`
}
type LoadBalancerAccessLogs struct {
	// The S3 bucket name to store the logs in.
	Bucket string `pulumi:"bucket"`
	// The S3 bucket prefix. Logs are stored in the root if not configured.
	BucketPrefix *string `pulumi:"bucketPrefix"`
	// Boolean to enable / disable `accessLogs`. Default is `true`
	Enabled *bool `pulumi:"enabled"`
	// The interval between checks.
	Interval *int `pulumi:"interval"`
}
var loadBalancerAccessLogsType = reflect.TypeOf((*LoadBalancerAccessLogs)(nil)).Elem()

type LoadBalancerAccessLogsInput interface {
	pulumi.Input

	ToLoadBalancerAccessLogsOutput() LoadBalancerAccessLogsOutput
	ToLoadBalancerAccessLogsOutputWithContext(ctx context.Context) LoadBalancerAccessLogsOutput
}

type LoadBalancerAccessLogsArgs struct {
	// The S3 bucket name to store the logs in.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The S3 bucket prefix. Logs are stored in the root if not configured.
	BucketPrefix pulumi.StringInput `pulumi:"bucketPrefix"`
	// Boolean to enable / disable `accessLogs`. Default is `true`
	Enabled pulumi.BoolInput `pulumi:"enabled"`
	// The interval between checks.
	Interval pulumi.IntInput `pulumi:"interval"`
}

func (LoadBalancerAccessLogsArgs) ElementType() reflect.Type {
	return loadBalancerAccessLogsType
}

func (a LoadBalancerAccessLogsArgs) ToLoadBalancerAccessLogsOutput() LoadBalancerAccessLogsOutput {
	return pulumi.ToOutput(a).(LoadBalancerAccessLogsOutput)
}

func (a LoadBalancerAccessLogsArgs) ToLoadBalancerAccessLogsOutputWithContext(ctx context.Context) LoadBalancerAccessLogsOutput {
	return pulumi.ToOutputWithContext(ctx, a).(LoadBalancerAccessLogsOutput)
}

type LoadBalancerAccessLogsOutput struct { *pulumi.OutputState }

// The S3 bucket name to store the logs in.
func (o LoadBalancerAccessLogsOutput) Bucket() pulumi.StringOutput {
	return o.Apply(func(v LoadBalancerAccessLogs) string {
		return v.Bucket
	}).(pulumi.StringOutput)
}

// The S3 bucket prefix. Logs are stored in the root if not configured.
func (o LoadBalancerAccessLogsOutput) BucketPrefix() pulumi.StringOutput {
	return o.Apply(func(v LoadBalancerAccessLogs) string {
		if v.BucketPrefix == nil { return *new(string) } else { return *v.BucketPrefix }
	}).(pulumi.StringOutput)
}

// Boolean to enable / disable `accessLogs`. Default is `true`
func (o LoadBalancerAccessLogsOutput) Enabled() pulumi.BoolOutput {
	return o.Apply(func(v LoadBalancerAccessLogs) bool {
		if v.Enabled == nil { return *new(bool) } else { return *v.Enabled }
	}).(pulumi.BoolOutput)
}

// The interval between checks.
func (o LoadBalancerAccessLogsOutput) Interval() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerAccessLogs) int {
		if v.Interval == nil { return *new(int) } else { return *v.Interval }
	}).(pulumi.IntOutput)
}

func (LoadBalancerAccessLogsOutput) ElementType() reflect.Type {
	return loadBalancerAccessLogsType
}

func (o LoadBalancerAccessLogsOutput) ToLoadBalancerAccessLogsOutput() LoadBalancerAccessLogsOutput {
	return o
}

func (o LoadBalancerAccessLogsOutput) ToLoadBalancerAccessLogsOutputWithContext(ctx context.Context) LoadBalancerAccessLogsOutput {
	return o
}

func init() { pulumi.RegisterOutputType(LoadBalancerAccessLogsOutput{}) }

type LoadBalancerHealthCheck struct {
	// The number of checks before the instance is declared healthy.
	HealthyThreshold int `pulumi:"healthyThreshold"`
	// The interval between checks.
	Interval int `pulumi:"interval"`
	// The target of the check. Valid pattern is "${PROTOCOL}:${PORT}${PATH}", where PROTOCOL
	// values are:
	// * `HTTP`, `HTTPS` - PORT and PATH are required
	// * `TCP`, `SSL` - PORT is required, PATH is not supported
	Target string `pulumi:"target"`
	// The length of time before the check times out.
	Timeout int `pulumi:"timeout"`
	// The number of checks before the instance is declared unhealthy.
	UnhealthyThreshold int `pulumi:"unhealthyThreshold"`
}
var loadBalancerHealthCheckType = reflect.TypeOf((*LoadBalancerHealthCheck)(nil)).Elem()

type LoadBalancerHealthCheckInput interface {
	pulumi.Input

	ToLoadBalancerHealthCheckOutput() LoadBalancerHealthCheckOutput
	ToLoadBalancerHealthCheckOutputWithContext(ctx context.Context) LoadBalancerHealthCheckOutput
}

type LoadBalancerHealthCheckArgs struct {
	// The number of checks before the instance is declared healthy.
	HealthyThreshold pulumi.IntInput `pulumi:"healthyThreshold"`
	// The interval between checks.
	Interval pulumi.IntInput `pulumi:"interval"`
	// The target of the check. Valid pattern is "${PROTOCOL}:${PORT}${PATH}", where PROTOCOL
	// values are:
	// * `HTTP`, `HTTPS` - PORT and PATH are required
	// * `TCP`, `SSL` - PORT is required, PATH is not supported
	Target pulumi.StringInput `pulumi:"target"`
	// The length of time before the check times out.
	Timeout pulumi.IntInput `pulumi:"timeout"`
	// The number of checks before the instance is declared unhealthy.
	UnhealthyThreshold pulumi.IntInput `pulumi:"unhealthyThreshold"`
}

func (LoadBalancerHealthCheckArgs) ElementType() reflect.Type {
	return loadBalancerHealthCheckType
}

func (a LoadBalancerHealthCheckArgs) ToLoadBalancerHealthCheckOutput() LoadBalancerHealthCheckOutput {
	return pulumi.ToOutput(a).(LoadBalancerHealthCheckOutput)
}

func (a LoadBalancerHealthCheckArgs) ToLoadBalancerHealthCheckOutputWithContext(ctx context.Context) LoadBalancerHealthCheckOutput {
	return pulumi.ToOutputWithContext(ctx, a).(LoadBalancerHealthCheckOutput)
}

type LoadBalancerHealthCheckOutput struct { *pulumi.OutputState }

// The number of checks before the instance is declared healthy.
func (o LoadBalancerHealthCheckOutput) HealthyThreshold() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerHealthCheck) int {
		return v.HealthyThreshold
	}).(pulumi.IntOutput)
}

// The interval between checks.
func (o LoadBalancerHealthCheckOutput) Interval() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerHealthCheck) int {
		return v.Interval
	}).(pulumi.IntOutput)
}

// The target of the check. Valid pattern is "${PROTOCOL}:${PORT}${PATH}", where PROTOCOL
// values are:
// * `HTTP`, `HTTPS` - PORT and PATH are required
// * `TCP`, `SSL` - PORT is required, PATH is not supported
func (o LoadBalancerHealthCheckOutput) Target() pulumi.StringOutput {
	return o.Apply(func(v LoadBalancerHealthCheck) string {
		return v.Target
	}).(pulumi.StringOutput)
}

// The length of time before the check times out.
func (o LoadBalancerHealthCheckOutput) Timeout() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerHealthCheck) int {
		return v.Timeout
	}).(pulumi.IntOutput)
}

// The number of checks before the instance is declared unhealthy.
func (o LoadBalancerHealthCheckOutput) UnhealthyThreshold() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerHealthCheck) int {
		return v.UnhealthyThreshold
	}).(pulumi.IntOutput)
}

func (LoadBalancerHealthCheckOutput) ElementType() reflect.Type {
	return loadBalancerHealthCheckType
}

func (o LoadBalancerHealthCheckOutput) ToLoadBalancerHealthCheckOutput() LoadBalancerHealthCheckOutput {
	return o
}

func (o LoadBalancerHealthCheckOutput) ToLoadBalancerHealthCheckOutputWithContext(ctx context.Context) LoadBalancerHealthCheckOutput {
	return o
}

func init() { pulumi.RegisterOutputType(LoadBalancerHealthCheckOutput{}) }

type LoadBalancerListeners struct {
	// The port on the instance to route to
	InstancePort int `pulumi:"instancePort"`
	// The protocol to use to the instance. Valid
	// values are `HTTP`, `HTTPS`, `TCP`, or `SSL`
	InstanceProtocol string `pulumi:"instanceProtocol"`
	// The port to listen on for the load balancer
	LbPort int `pulumi:"lbPort"`
	// The protocol to listen on. Valid values are `HTTP`,
	// `HTTPS`, `TCP`, or `SSL`
	LbProtocol string `pulumi:"lbProtocol"`
	// The ARN of an SSL certificate you have
	// uploaded to AWS IAM. **Note ECDSA-specific restrictions below.  Only valid when `lbProtocol` is either HTTPS or SSL**
	SslCertificateId *string `pulumi:"sslCertificateId"`
}
var loadBalancerListenersType = reflect.TypeOf((*LoadBalancerListeners)(nil)).Elem()

type LoadBalancerListenersInput interface {
	pulumi.Input

	ToLoadBalancerListenersOutput() LoadBalancerListenersOutput
	ToLoadBalancerListenersOutputWithContext(ctx context.Context) LoadBalancerListenersOutput
}

type LoadBalancerListenersArgs struct {
	// The port on the instance to route to
	InstancePort pulumi.IntInput `pulumi:"instancePort"`
	// The protocol to use to the instance. Valid
	// values are `HTTP`, `HTTPS`, `TCP`, or `SSL`
	InstanceProtocol pulumi.StringInput `pulumi:"instanceProtocol"`
	// The port to listen on for the load balancer
	LbPort pulumi.IntInput `pulumi:"lbPort"`
	// The protocol to listen on. Valid values are `HTTP`,
	// `HTTPS`, `TCP`, or `SSL`
	LbProtocol pulumi.StringInput `pulumi:"lbProtocol"`
	// The ARN of an SSL certificate you have
	// uploaded to AWS IAM. **Note ECDSA-specific restrictions below.  Only valid when `lbProtocol` is either HTTPS or SSL**
	SslCertificateId pulumi.StringInput `pulumi:"sslCertificateId"`
}

func (LoadBalancerListenersArgs) ElementType() reflect.Type {
	return loadBalancerListenersType
}

func (a LoadBalancerListenersArgs) ToLoadBalancerListenersOutput() LoadBalancerListenersOutput {
	return pulumi.ToOutput(a).(LoadBalancerListenersOutput)
}

func (a LoadBalancerListenersArgs) ToLoadBalancerListenersOutputWithContext(ctx context.Context) LoadBalancerListenersOutput {
	return pulumi.ToOutputWithContext(ctx, a).(LoadBalancerListenersOutput)
}

type LoadBalancerListenersOutput struct { *pulumi.OutputState }

// The port on the instance to route to
func (o LoadBalancerListenersOutput) InstancePort() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerListeners) int {
		return v.InstancePort
	}).(pulumi.IntOutput)
}

// The protocol to use to the instance. Valid
// values are `HTTP`, `HTTPS`, `TCP`, or `SSL`
func (o LoadBalancerListenersOutput) InstanceProtocol() pulumi.StringOutput {
	return o.Apply(func(v LoadBalancerListeners) string {
		return v.InstanceProtocol
	}).(pulumi.StringOutput)
}

// The port to listen on for the load balancer
func (o LoadBalancerListenersOutput) LbPort() pulumi.IntOutput {
	return o.Apply(func(v LoadBalancerListeners) int {
		return v.LbPort
	}).(pulumi.IntOutput)
}

// The protocol to listen on. Valid values are `HTTP`,
// `HTTPS`, `TCP`, or `SSL`
func (o LoadBalancerListenersOutput) LbProtocol() pulumi.StringOutput {
	return o.Apply(func(v LoadBalancerListeners) string {
		return v.LbProtocol
	}).(pulumi.StringOutput)
}

// The ARN of an SSL certificate you have
// uploaded to AWS IAM. **Note ECDSA-specific restrictions below.  Only valid when `lbProtocol` is either HTTPS or SSL**
func (o LoadBalancerListenersOutput) SslCertificateId() pulumi.StringOutput {
	return o.Apply(func(v LoadBalancerListeners) string {
		if v.SslCertificateId == nil { return *new(string) } else { return *v.SslCertificateId }
	}).(pulumi.StringOutput)
}

func (LoadBalancerListenersOutput) ElementType() reflect.Type {
	return loadBalancerListenersType
}

func (o LoadBalancerListenersOutput) ToLoadBalancerListenersOutput() LoadBalancerListenersOutput {
	return o
}

func (o LoadBalancerListenersOutput) ToLoadBalancerListenersOutputWithContext(ctx context.Context) LoadBalancerListenersOutput {
	return o
}

func init() { pulumi.RegisterOutputType(LoadBalancerListenersOutput{}) }

var loadBalancerListenersArrayType = reflect.TypeOf((*[]LoadBalancerListeners)(nil)).Elem()

type LoadBalancerListenersArrayInput interface {
	pulumi.Input

	ToLoadBalancerListenersArrayOutput() LoadBalancerListenersArrayOutput
	ToLoadBalancerListenersArrayOutputWithContext(ctx context.Context) LoadBalancerListenersArrayOutput
}

type LoadBalancerListenersArrayArgs []LoadBalancerListenersInput

func (LoadBalancerListenersArrayArgs) ElementType() reflect.Type {
	return loadBalancerListenersArrayType
}

func (a LoadBalancerListenersArrayArgs) ToLoadBalancerListenersArrayOutput() LoadBalancerListenersArrayOutput {
	return pulumi.ToOutput(a).(LoadBalancerListenersArrayOutput)
}

func (a LoadBalancerListenersArrayArgs) ToLoadBalancerListenersArrayOutputWithContext(ctx context.Context) LoadBalancerListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, a).(LoadBalancerListenersArrayOutput)
}

type LoadBalancerListenersArrayOutput struct { *pulumi.OutputState }

func (o LoadBalancerListenersArrayOutput) Index(i pulumi.IntInput) LoadBalancerListenersOutput {
	return pulumi.All(o, i).Apply(func(vs []interface{}) LoadBalancerListeners {
		return vs[0].([]LoadBalancerListeners)[vs[1].(int)]
	}).(LoadBalancerListenersOutput)
}

func (LoadBalancerListenersArrayOutput) ElementType() reflect.Type {
	return loadBalancerListenersArrayType
}

func (o LoadBalancerListenersArrayOutput) ToLoadBalancerListenersArrayOutput() LoadBalancerListenersArrayOutput {
	return o
}

func (o LoadBalancerListenersArrayOutput) ToLoadBalancerListenersArrayOutputWithContext(ctx context.Context) LoadBalancerListenersArrayOutput {
	return o
}

func init() { pulumi.RegisterOutputType(LoadBalancerListenersArrayOutput{}) }

